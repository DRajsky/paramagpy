%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,10pt,english,openany,oneside]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
\edef\sphinxdqmaybe{\ifdefined\DeclareUnicodeCharacterAsOptional\string"\fi}
  \DeclareUnicodeCharacter{\sphinxdqmaybe00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}
\addto\captionsenglish{\renewcommand{\sphinxnonalphabeticalgroupname}{Non-alphabetical}}
\addto\captionsenglish{\renewcommand{\sphinxsymbolsname}{Symbols}}
\addto\captionsenglish{\renewcommand{\sphinxnumbersname}{Numbers}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}

\setcounter{tocdepth}{1}

\title{paramagpy Documentation}
\date{Aug 19, 2019}
\release{0.43}
\author{Henry Orton}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\maketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}

\begin{quote}\begin{description}
\item[{Release}] \leavevmode
0.43

\item[{Date}] \leavevmode
Aug 19, 2019

\end{description}\end{quote}


\chapter{Introduction}
\label{\detokenize{index:introduction}}
paramagpy is a python module for calculating paramagnetic effects in NMR spectra of proteins. This currently includes fitting of paramagnetic susceptibility tensors to experimental data associated with pseudocontact shifts (PCS) residual dipolar couplings (RDC), paramagnetic relaxation enhancements (PRE) and cross-correlated relaxation (CCR). A GUI allows easy viewing of data and seamless transition between PCS/RDC/PR/CCR calculations.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{icon}.png}
\caption{\sphinxstyleemphasis{Please, not the eyes!} - Canberra cyclist}\label{\detokenize{index:id1}}\end{figure}


\chapter{Features}
\label{\detokenize{index:features}}\begin{itemize}
\item {} 
Support for PDB protein structures with models

\item {} 
Combined SVD gridsearch and gradient descent algorithms for solving PCS tensors

\item {} 
Optional fitting of reference offset parameter for PCS datasets

\item {} 
Support for Residual Anisotropic Chemical Shielding (RACS) and Residual Anisotropic Dipolar Shielding (RADS) corrections to PCS

\item {} 
Lanthanide parameter templates available

\item {} 
Plotting of correlation between experiment/calculated values

\item {} 
Plotting of tensor isosurfaces compatible with PyMol

\item {} 
Q-factor calculations

\item {} 
Error analysis of tensor fit quality Monte-Carlo or Bootstrap methods

\item {} 
Optimisation of multiple PCS/PRE/CCR datasets to a common position

\item {} 
Unique tensor representation compatible with Numbat (program)

\item {} 
Fitting of RDC tensor by SVD algorithm

\item {} 
PRE calculations by Solomon and Curie spin mechanisms

\item {} 
CSA cross-correlation correction to PRE calculations

\item {} 
Dipole-dipole/Curie spin cross-correlated relaxation calculations

\item {} 
Fitting of tensor parameters to PRE/CCR data

\item {} 
Macro scripts for integration with CCPNMR and Sparky

\end{itemize}


\chapter{Documentation}
\label{\detokenize{index:documentation}}\begin{itemize}
\item {} 
\sphinxurl{https://henryorton.github.io/paramagpy/}

\end{itemize}


\chapter{Citing paramagpy}
\label{\detokenize{index:citing-paramagpy}}
Hopefully paramagpy will be published soon the journal of biomolecular NMR


\chapter{Contents}
\label{\detokenize{index:contents}}

\section{Installation Guide}
\label{\detokenize{install:installation-guide}}\label{\detokenize{install::doc}}

\subsection{Requirements}
\label{\detokenize{install:requirements}}
Paramagpy is written for python 3. It requires packages:
\begin{itemize}
\item {} 
\sphinxhref{http://numpy.scipy.org}{NumPy}

\item {} 
\sphinxhref{http://www.scipy.org}{SciPy}

\item {} 
\sphinxhref{http://matplotlib.org/}{matplotlib}

\item {} 
\sphinxhref{https://biopython.org/}{BioPython}

\end{itemize}


\subsection{Unix/OSX Installation}
\label{\detokenize{install:unix-osx-installation}}
Install directly using pip:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} pip install paramagpy
\end{sphinxVerbatim}

Or, download the \sphinxhref{https://github.com/henryorton/paramagpy}{source code} and run:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} python setup.py install
\end{sphinxVerbatim}

within the source directory.


\subsection{Windows Installation}
\label{\detokenize{install:windows-installation}}
Paramagpy has never been tested on windows, but theoretically it should work. Good luck!


\subsection{Running the GUI}
\label{\detokenize{install:running-the-gui}}
Once you have installed paramagpy, see {\hyperref[\detokenize{paramagpy_gui:paramagpy-gui}]{\sphinxcrossref{\DUrole{std,std-ref}{Graphic User Interface (GUI)}}}} for how to run the GUI.


\section{Examples}
\label{\detokenize{examples/index:examples}}\label{\detokenize{examples/index:examples-index}}\label{\detokenize{examples/index::doc}}

\subsection{PCS data}
\label{\detokenize{examples/index:pcs-data}}

\subsubsection{Fit Tensor to PCS Data}
\label{\detokenize{examples/pcs_fit:fit-tensor-to-pcs-data}}\label{\detokenize{examples/pcs_fit:pcs-fit}}\label{\detokenize{examples/pcs_fit::doc}}
This example shows how to fit a \({\Delta\chi}\)-tensor to experimental PCS data for the protein calbindin D9k. These data contain amide 1H and 15N chemical shifts between diamagnetic and paramagnetic states with the lanthanide Er3+ bound.


\paragraph{Downloads}
\label{\detokenize{examples/pcs_fit:downloads}}\begin{itemize}
\item {} 
Download the data files \sphinxcode{\sphinxupquote{4icbH\_mut.pdb}} and \sphinxcode{\sphinxupquote{calbindin\_Er\_HN\_PCS.npc}} from \sphinxhref{https://github.com/henryorton/paramagpy/tree/master/examples/data\_files/}{here}:

\item {} 
Download the script \sphinxcode{\sphinxupquote{pcs\_fit.py}}

\end{itemize}


\paragraph{Script + Explanation}
\label{\detokenize{examples/pcs_fit:script-explanation}}
Firstly, the necessary modules are imported from paramagpy.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{paramagpy} \PYG{k}{import} \PYG{n}{protein}\PYG{p}{,} \PYG{n}{fit}\PYG{p}{,} \PYG{n}{dataparse}\PYG{p}{,} \PYG{n}{metal}
\end{sphinxVerbatim}

The protein is then loaded from a PDB file using {\hyperref[\detokenize{reference/generated/paramagpy.protein.load_pdb:paramagpy.protein.load_pdb}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.protein.load\_pdb()}}}}} into the variable \sphinxcode{\sphinxupquote{prot}}. This returns a \sphinxcode{\sphinxupquote{CustomStructure}} object which is closely based on the \sphinxcode{\sphinxupquote{Structure}} object from \sphinxhref{https://biopython.org/}{BioPython} and contains the atomic coordinates. The object, and how to access atomic coordinates is discussed at this \sphinxhref{https://biopython.org/wiki/The\_Biopython\_Structural\_Bioinformatics\_FAQ}{link}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Load the PDB file}
\PYG{n}{prot} \PYG{o}{=} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{load\PYGZus{}pdb}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/4icbH\PYGZus{}mut.pdb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

The PCS data is then loaded from a \sphinxcode{\sphinxupquote{.npc}} file using the function {\hyperref[\detokenize{reference/generated/paramagpy.dataparse.read_pcs:paramagpy.dataparse.read_pcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.dataparse.read\_pcs()}}}}} into the variable \sphinxcode{\sphinxupquote{rawData}}. This is a dictionary of \sphinxcode{\sphinxupquote{(PCS, Error)}} tuples which may be accessed by \sphinxcode{\sphinxupquote{rawData{[}(seq, atom){]}}} where \sphinxcode{\sphinxupquote{seq}} is an integer specifying the sequence and \sphinxcode{\sphinxupquote{atom}} is the atom name e.g \sphinxcode{\sphinxupquote{(3,'HA')}}. Note that these should match the corresponding sequence and atom in the PDB file.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Load the PCS data}
\PYG{n}{rawData} \PYG{o}{=} \PYG{n}{dataparse}\PYG{o}{.}\PYG{n}{read\PYGZus{}pcs}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/calbindin\PYGZus{}Er\PYGZus{}HN\PYGZus{}PCS.npc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

To associate the experimental PCS value with atoms of the PDB structure, the method {\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.parse:paramagpy.protein.CustomStructure.parse}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.protein.CustomStructure.parse()}}}}} is called on \sphinxcode{\sphinxupquote{rawData}}. The new list \sphinxcode{\sphinxupquote{parsedData}} contains elements \sphinxcode{\sphinxupquote{{[}atom, PCS, Error{]}}}, where \sphinxcode{\sphinxupquote{atom}} is now an atom object from the PDB.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Associate PCS data with atoms of the PDB}
\PYG{n}{parsedData} \PYG{o}{=} \PYG{n}{prot}\PYG{o}{.}\PYG{n}{parse}\PYG{p}{(}\PYG{n}{rawData}\PYG{p}{)}
\end{sphinxVerbatim}

An initial \({\Delta\chi}\)-tensor is defined by initialising a {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal:paramagpy.metal.Metal}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal}}}}} object. The initial position is known to be near the binding site, which is set to the CA atom of residue 56. Note that the \sphinxcode{\sphinxupquote{position}} attribute is always in Angstrom units.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Define an initial tensor}
\PYG{n}{mStart} \PYG{o}{=} \PYG{n}{metal}\PYG{o}{.}\PYG{n}{Metal}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Set the starting position to an atom close to the metal}
\PYG{n}{mStart}\PYG{o}{.}\PYG{n}{position} \PYG{o}{=} \PYG{n}{prot}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{56}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{CA}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{position}
\end{sphinxVerbatim}

A quick gridsearch is conducted in a sphere of 10 Angstrom with 10 points per radius using the function {\hyperref[\detokenize{reference/generated/paramagpy.fit.svd_gridsearch_fit_metal_from_pcs:paramagpy.fit.svd_gridsearch_fit_metal_from_pcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.fit.svd\_gridsearch\_fit\_metal\_from\_pcs()}}}}}. This requires two lists containing the starting metals \sphinxcode{\sphinxupquote{mStart}} and parsed experimental data \sphinxcode{\sphinxupquote{parsedData}}. This function return lists containing a new fitted metal object, the calculated PCS values from the fitted model, and the Q-factor.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Calculate an initial tensor from an SVD gridsearch}
\PYG{n}{mGuess}\PYG{p}{,} \PYG{n}{calc}\PYG{p}{,} \PYG{n}{qfac} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{svd\PYGZus{}gridsearch\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pcs}\PYG{p}{(}
	\PYG{p}{[}\PYG{n}{mStart}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{n}{parsedData}\PYG{p}{]}\PYG{p}{,} \PYG{n}{radius}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{points}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}
\end{sphinxVerbatim}

This is then refined using a non-linear regression gradient descent with the function {\hyperref[\detokenize{reference/generated/paramagpy.fit.nlr_fit_metal_from_pcs:paramagpy.fit.nlr_fit_metal_from_pcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.fit.nlr\_fit\_metal\_from\_pcs()}}}}}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Refine the tensor using non\PYGZhy{}linear regression}
\PYG{n}{mFit}\PYG{p}{,} \PYG{n}{calc}\PYG{p}{,} \PYG{n}{qfac} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{nlr\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pcs}\PYG{p}{(}\PYG{n}{mGuess}\PYG{p}{,} \PYG{p}{[}\PYG{n}{parsedData}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

The fitted tensor parameters are saved by calling the method {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.save:paramagpy.metal.Metal.save}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.save()}}}}}. Alterntaively they may be displayed using \sphinxcode{\sphinxupquote{print(mFit{[}0{]}.info())}}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Save the fitted tensor to file}
\PYG{n}{mFit}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{calbindin\PYGZus{}Er\PYGZus{}HN\PYGZus{}PCS\PYGZus{}tensor.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{calbindin\_Er\_HN\_PCS\_tensor.txt}}{]}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
ax    \textbar{} 1E\PYGZhy{}32 m\PYGZca{}3 :    \PYGZhy{}8.688
rh    \textbar{} 1E\PYGZhy{}32 m\PYGZca{}3 :    \PYGZhy{}4.192
x     \textbar{}   1E\PYGZhy{}10 m :    25.517
y     \textbar{}   1E\PYGZhy{}10 m :     8.652
z     \textbar{}   1E\PYGZhy{}10 m :     6.358
a     \textbar{}       deg :   116.011
b     \textbar{}       deg :   138.058
g     \textbar{}       deg :    43.492
mueff \textbar{}        Bm :     0.000
shift \textbar{}       ppm :     0.000
B0    \textbar{}         T :    18.790
temp  \textbar{}         K :   298.150
t1e   \textbar{}        ps :     0.000
taur  \textbar{}        ns :     0.000
\end{sphinxVerbatim}

These experimental/calculated PCS values are then plotted in a correlation plot to assess the fit. This is achieved using standard functions of the plotting module \sphinxhref{https://matplotlib.org/}{matplotlib}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{} Plot the correlation \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{k+kn}{from} \PYG{n+nn}{matplotlib} \PYG{k}{import} \PYG{n}{pyplot} \PYG{k}{as} \PYG{n}{plt}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Unpack the experimental values}
\PYG{n}{atoms}\PYG{p}{,} \PYG{n}{experiment}\PYG{p}{,} \PYG{n}{errors} \PYG{o}{=} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{o}{*}\PYG{n}{parsedData}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot the data}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{experiment}\PYG{p}{,} \PYG{n}{calc}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ms}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
	\PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q\PYGZhy{}factor = }\PYG{l+s+si}{\PYGZob{}:5.4f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{qfac}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot a diagonal}
\PYG{n}{l}\PYG{p}{,} \PYG{n}{h} \PYG{o}{=} \PYG{n}{ax}\PYG{o}{.}\PYG{n}{get\PYGZus{}xlim}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}k}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlim}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Make axis labels and save figure}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Experiment}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Calculated}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pcs\PYGZus{}fit.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{pcs\_fit.png}}{]}

\noindent\sphinxincludegraphics{{pcs_fit}.png}


\subsubsection{Plot PCS isosurface (PyMol view)}
\label{\detokenize{examples/pcs_plot_isosurface:plot-pcs-isosurface-pymol-view}}\label{\detokenize{examples/pcs_plot_isosurface:pcs-plot-isosurface}}\label{\detokenize{examples/pcs_plot_isosurface::doc}}
This example shows how to plot the PCS isosurface of a fitted \({\Delta\chi}\)-tensor for data from the example {\hyperref[\detokenize{examples/pcs_fit:pcs-fit}]{\sphinxcrossref{\DUrole{std,std-ref}{Fit Tensor to PCS Data}}}}. The isosurface can be viewed in \sphinxhref{https://pymol.org}{PyMol}.


\paragraph{Downloads}
\label{\detokenize{examples/pcs_plot_isosurface:downloads}}\begin{itemize}
\item {} 
Download the data files \sphinxcode{\sphinxupquote{4icbH\_mut.pdb}} and \sphinxcode{\sphinxupquote{calbindin\_Er\_HN\_PCS\_tensor.txt}} from \sphinxhref{https://github.com/henryorton/paramagpy/tree/master/examples/data\_files/}{here}:

\item {} 
Download the script \sphinxhref{https://github.com/henryorton/paramagpy/tree/master/examples/pcs\_plot\_isosurface/pcs\_plot\_isosurface.py}{pcs\_plot\_isosurface.py}

\end{itemize}


\paragraph{Explanation}
\label{\detokenize{examples/pcs_plot_isosurface:explanation}}
The protein and tensor are loaded as described previously in.

The isosurface files are generated using the function {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.isomap:paramagpy.metal.Metal.isomap}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.isomap()}}}}}. The contour level can be chosen by setting the \sphinxcode{\sphinxupquote{isoval}} argument. A larger \sphinxcode{\sphinxupquote{density}} value will result in a smoother surface. This function writes two files \sphinxcode{\sphinxupquote{isomap.pml}} and \sphinxcode{\sphinxupquote{isomap.pml.ccp4}} which are the PyMol script and PCS grid files respectively.

The isosurface can be displayed by executing \sphinxcode{\sphinxupquote{pymol isomap.pml}} from a terminal, or by selecting \sphinxcode{\sphinxupquote{File\textgreater{}Run}} and navigating to the script \sphinxcode{\sphinxupquote{isomap.pml}}.


\paragraph{Script}
\label{\detokenize{examples/pcs_plot_isosurface:script}}
{[}\sphinxcode{\sphinxupquote{pcs\_plot\_isosurface.py}}{]}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{paramagpy} \PYG{k}{import} \PYG{n}{protein}\PYG{p}{,} \PYG{n}{fit}\PYG{p}{,} \PYG{n}{dataparse}\PYG{p}{,} \PYG{n}{metal}

\PYG{c+c1}{\PYGZsh{} Load the PDB file}
\PYG{n}{prot} \PYG{o}{=} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{load\PYGZus{}pdb}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/4icbH\PYGZus{}mut.pdb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Load the fitted tensor}
\PYG{n}{met} \PYG{o}{=} \PYG{n}{metal}\PYG{o}{.}\PYG{n}{load\PYGZus{}tensor}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/calbindin\PYGZus{}Er\PYGZus{}HN\PYGZus{}PCS\PYGZus{}tensor.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot the isosurface to be opened in PyMol}
\PYG{n}{met}\PYG{o}{.}\PYG{n}{isomap}\PYG{p}{(}\PYG{n}{prot}\PYG{o}{.}\PYG{n}{id}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{isoval}\PYG{o}{=}\PYG{l+m+mf}{1.0}\PYG{p}{)}
\end{sphinxVerbatim}


\paragraph{Output}
\label{\detokenize{examples/pcs_plot_isosurface:output}}
\sphinxstyleemphasis{PyMol view of isosurface}

{[}\sphinxcode{\sphinxupquote{pcs\_plot\_isosurface.png}}{]}

\noindent\sphinxincludegraphics{{pcs_plot_isosurface}.png}


\subsubsection{Fit multiple PCS datasets to common position}
\label{\detokenize{examples/pcs_fit_multiple:fit-multiple-pcs-datasets-to-common-position}}\label{\detokenize{examples/pcs_fit_multiple:pcs-fit-multiple}}\label{\detokenize{examples/pcs_fit_multiple::doc}}
This example shows how to fit multiple \({\Delta\chi}\)-tensors to their respective datasets with a common position, but varied magnitude and orientation. This may arise if several lanthanides were investigated at the same binding site, and the data may be used simultaneously to fit a common position. Data from several PCS datasets for calbindin D9k were used here, and is a generalisation of the previous example: {\hyperref[\detokenize{examples/pcs_fit:pcs-fit}]{\sphinxcrossref{\DUrole{std,std-ref}{Fit Tensor to PCS Data}}}}.


\paragraph{Downloads}
\label{\detokenize{examples/pcs_fit_multiple:downloads}}\begin{itemize}
\item {} 
Download the data files \sphinxcode{\sphinxupquote{4icbH\_mut.pdb}}, \sphinxcode{\sphinxupquote{calbindin\_Tb\_HN\_PCS.npc}}, \sphinxcode{\sphinxupquote{calbindin\_Er\_HN\_PCS.npc}} and \sphinxcode{\sphinxupquote{calbindin\_Yb\_HN\_PCS\_tensor.txt}} from \sphinxhref{https://github.com/henryorton/paramagpy/tree/master/examples/data\_files/}{here}:

\item {} 
Download the script \sphinxhref{https://github.com/henryorton/paramagpy/tree/master/examples/pcs\_fit\_multiple/pcs\_fit\_multiple.py}{pcs\_fit\_multiple.py}

\end{itemize}


\paragraph{Explanation}
\label{\detokenize{examples/pcs_fit_multiple:explanation}}
The protein and PCS datasets are loaded and parsed. These are placed into a list \sphinxcode{\sphinxupquote{parsedData}}, for which each element is a PCS dataset of a given lanthanide.

The two fitting functions:
\begin{itemize}
\item {} 
{\hyperref[\detokenize{reference/generated/paramagpy.fit.svd_gridsearch_fit_metal_from_pcs:paramagpy.fit.svd_gridsearch_fit_metal_from_pcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.fit.svd\_gridsearch\_fit\_metal\_from\_pcs()}}}}}

\item {} 
{\hyperref[\detokenize{reference/generated/paramagpy.fit.nlr_fit_metal_from_pcs:paramagpy.fit.nlr_fit_metal_from_pcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.fit.nlr\_fit\_metal\_from\_pcs()}}}}}

\end{itemize}

can accept a list of metal objects and a list of datasets with arbitrary size. If this list contains more than one element, fitting will be performed to a common position. The starting position is taken only from the first metal of the list.

After fitting, a list of fitted metals is returned. The fitted tensor are then written to files and a correlation plot is made.


\paragraph{Script}
\label{\detokenize{examples/pcs_fit_multiple:script}}
{[}\sphinxcode{\sphinxupquote{pcs\_fit\_multiple.py}}{]}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{paramagpy} \PYG{k}{import} \PYG{n}{protein}\PYG{p}{,} \PYG{n}{fit}\PYG{p}{,} \PYG{n}{dataparse}\PYG{p}{,} \PYG{n}{metal}

\PYG{c+c1}{\PYGZsh{} Load the PDB file}
\PYG{n}{prot} \PYG{o}{=} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{load\PYGZus{}pdb}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/4icbH\PYGZus{}mut.pdb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Load the PCS data}
\PYG{n}{rawData1} \PYG{o}{=} \PYG{n}{dataparse}\PYG{o}{.}\PYG{n}{read\PYGZus{}pcs}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/calbindin\PYGZus{}Tb\PYGZus{}HN\PYGZus{}PCS.npc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{rawData2} \PYG{o}{=} \PYG{n}{dataparse}\PYG{o}{.}\PYG{n}{read\PYGZus{}pcs}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/calbindin\PYGZus{}Er\PYGZus{}HN\PYGZus{}PCS.npc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{rawData3} \PYG{o}{=} \PYG{n}{dataparse}\PYG{o}{.}\PYG{n}{read\PYGZus{}pcs}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/calbindin\PYGZus{}Yb\PYGZus{}HN\PYGZus{}PCS.npc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Associate PCS data with atoms of the PDB}
\PYG{n}{parsedData} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{rd} \PYG{o+ow}{in} \PYG{p}{[}\PYG{n}{rawData1}\PYG{p}{,} \PYG{n}{rawData2}\PYG{p}{,} \PYG{n}{rawData3}\PYG{p}{]}\PYG{p}{:}
	\PYG{n}{parsedData}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{prot}\PYG{o}{.}\PYG{n}{parse}\PYG{p}{(}\PYG{n}{rd}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Make a list of starting tensors}
\PYG{n}{mStart} \PYG{o}{=} \PYG{p}{[}\PYG{n}{metal}\PYG{o}{.}\PYG{n}{Metal}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{metal}\PYG{o}{.}\PYG{n}{Metal}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{metal}\PYG{o}{.}\PYG{n}{Metal}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Set the starting position to an atom close to the metal}
\PYG{n}{mStart}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{position} \PYG{o}{=} \PYG{n}{prot}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{56}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{CA}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{position}

\PYG{c+c1}{\PYGZsh{} Calculate initial tensors from an SVD gridsearch}
\PYG{n}{mGuess} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{svd\PYGZus{}gridsearch\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pcs}\PYG{p}{(}
	\PYG{n}{mStart}\PYG{p}{,} \PYG{n}{parsedData}\PYG{p}{,} \PYG{n}{radius}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{points}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Refine the tensors using non\PYGZhy{}linear regression}
\PYG{n}{fitParameters} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ax}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rh}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{g}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{mFit} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{nlr\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pcs}\PYG{p}{(}\PYG{n}{mGuess}\PYG{p}{,} \PYG{n}{parsedData}\PYG{p}{,} \PYG{n}{fitParameters}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Save the fitted tensors to files}
\PYG{k}{for} \PYG{n}{name}\PYG{p}{,} \PYG{n}{metal} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Tb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Er}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Yb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{mFit}\PYG{p}{)}\PYG{p}{:}
	\PYG{n}{metal}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{tensor\PYGZus{}}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{name}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Make experimental and calculated PCS lists}
\PYG{n}{exp} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{cal} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{metal}\PYG{p}{,} \PYG{n}{data} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{mFit}\PYG{p}{,} \PYG{n}{parsedData}\PYG{p}{)}\PYG{p}{:}
	\PYG{n}{ex} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
	\PYG{n}{ca} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
	\PYG{k}{for} \PYG{n}{atom}\PYG{p}{,} \PYG{n}{exp\PYGZus{}pcs}\PYG{p}{,} \PYG{n}{error} \PYG{o+ow}{in} \PYG{n}{data}\PYG{p}{:}
		\PYG{n}{ex}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{exp\PYGZus{}pcs}\PYG{p}{)}
		\PYG{n}{ca}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{metal}\PYG{o}{.}\PYG{n}{atom\PYGZus{}pcs}\PYG{p}{(}\PYG{n}{atom}\PYG{p}{)}\PYG{p}{)}
	\PYG{n}{exp}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{ex}\PYG{p}{)}
	\PYG{n}{cal}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{ca}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{} Plot the correlation \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{k+kn}{from} \PYG{n+nn}{matplotlib} \PYG{k}{import} \PYG{n}{pyplot} \PYG{k}{as} \PYG{n}{plt}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot the data}
\PYG{k}{for} \PYG{n}{e}\PYG{p}{,} \PYG{n}{c}\PYG{p}{,} \PYG{n}{name}\PYG{p}{,} \PYG{n}{colour} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{exp}\PYG{p}{,} \PYG{n}{cal}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Tb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Er}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Yb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{g}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
	\PYG{n}{qfactor} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{qfactor}\PYG{p}{(}\PYG{n}{e}\PYG{p}{,}\PYG{n}{c}\PYG{p}{)}
	\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{e}\PYG{p}{,} \PYG{n}{c}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ms}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{n}{colour}\PYG{p}{,}
		\PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}0:\PYGZcb{}}\PYG{l+s+s2}{ \PYGZhy{} }\PYG{l+s+si}{\PYGZob{}1:5.3f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{name}\PYG{p}{,} \PYG{n}{qfactor}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot a diagonal}
\PYG{n}{l}\PYG{p}{,} \PYG{n}{h} \PYG{o}{=} \PYG{n}{ax}\PYG{o}{.}\PYG{n}{get\PYGZus{}xlim}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}k}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlim}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Axis labels}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Experiment}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Calculated}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pcs\PYGZus{}fit\PYGZus{}multiple.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}


\paragraph{Outputs}
\label{\detokenize{examples/pcs_fit_multiple:outputs}}
\sphinxstyleemphasis{Tb fitted tensor}

{[}\sphinxcode{\sphinxupquote{tensor\_Tb.txt}}{]}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ax}    \PYG{o}{\textbar{}} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}    \PYG{l+m+mf}{31.096}
\PYG{n}{rh}    \PYG{o}{\textbar{}} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}    \PYG{l+m+mf}{12.328}
\PYG{n}{x}     \PYG{o}{\textbar{}}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}    \PYG{l+m+mf}{25.937}
\PYG{n}{y}     \PYG{o}{\textbar{}}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{9.481}
\PYG{n}{z}     \PYG{o}{\textbar{}}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{6.597}
\PYG{n}{a}     \PYG{o}{\textbar{}}       \PYG{n}{deg} \PYG{p}{:}   \PYG{l+m+mf}{151.053}
\PYG{n}{b}     \PYG{o}{\textbar{}}       \PYG{n}{deg} \PYG{p}{:}   \PYG{l+m+mf}{152.849}
\PYG{n}{g}     \PYG{o}{\textbar{}}       \PYG{n}{deg} \PYG{p}{:}    \PYG{l+m+mf}{69.821}
\PYG{n}{mueff} \PYG{o}{\textbar{}}        \PYG{n}{Bm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{shift} \PYG{o}{\textbar{}}       \PYG{n}{ppm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{B0}    \PYG{o}{\textbar{}}         \PYG{n}{T} \PYG{p}{:}    \PYG{l+m+mf}{18.790}
\PYG{n}{temp}  \PYG{o}{\textbar{}}         \PYG{n}{K} \PYG{p}{:}   \PYG{l+m+mf}{298.150}
\PYG{n}{t1e}   \PYG{o}{\textbar{}}        \PYG{n}{ps} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\end{sphinxVerbatim}

\sphinxstyleemphasis{Er fitted tensor}

{[}\sphinxcode{\sphinxupquote{tensor\_Er.txt}}{]}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ax}    \PYG{o}{\textbar{}} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{8.421}
\PYG{n}{rh}    \PYG{o}{\textbar{}} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.886}
\PYG{n}{x}     \PYG{o}{\textbar{}}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}    \PYG{l+m+mf}{25.937}
\PYG{n}{y}     \PYG{o}{\textbar{}}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{9.481}
\PYG{n}{z}     \PYG{o}{\textbar{}}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{6.597}
\PYG{n}{a}     \PYG{o}{\textbar{}}       \PYG{n}{deg} \PYG{p}{:}   \PYG{l+m+mf}{126.015}
\PYG{n}{b}     \PYG{o}{\textbar{}}       \PYG{n}{deg} \PYG{p}{:}   \PYG{l+m+mf}{142.899}
\PYG{n}{g}     \PYG{o}{\textbar{}}       \PYG{n}{deg} \PYG{p}{:}    \PYG{l+m+mf}{41.040}
\PYG{n}{mueff} \PYG{o}{\textbar{}}        \PYG{n}{Bm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{shift} \PYG{o}{\textbar{}}       \PYG{n}{ppm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{B0}    \PYG{o}{\textbar{}}         \PYG{n}{T} \PYG{p}{:}    \PYG{l+m+mf}{18.790}
\PYG{n}{temp}  \PYG{o}{\textbar{}}         \PYG{n}{K} \PYG{p}{:}   \PYG{l+m+mf}{298.150}
\PYG{n}{t1e}   \PYG{o}{\textbar{}}        \PYG{n}{ps} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\end{sphinxVerbatim}

\sphinxstyleemphasis{Yb fitted tensor}

{[}\sphinxcode{\sphinxupquote{tensor\_Yb.txt}}{]}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ax}    \PYG{o}{\textbar{}} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.392}
\PYG{n}{rh}    \PYG{o}{\textbar{}} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.490}
\PYG{n}{x}     \PYG{o}{\textbar{}}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}    \PYG{l+m+mf}{25.937}
\PYG{n}{y}     \PYG{o}{\textbar{}}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{9.481}
\PYG{n}{z}     \PYG{o}{\textbar{}}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{6.597}
\PYG{n}{a}     \PYG{o}{\textbar{}}       \PYG{n}{deg} \PYG{p}{:}   \PYG{l+m+mf}{129.650}
\PYG{n}{b}     \PYG{o}{\textbar{}}       \PYG{n}{deg} \PYG{p}{:}   \PYG{l+m+mf}{137.708}
\PYG{n}{g}     \PYG{o}{\textbar{}}       \PYG{n}{deg} \PYG{p}{:}    \PYG{l+m+mf}{88.796}
\PYG{n}{mueff} \PYG{o}{\textbar{}}        \PYG{n}{Bm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{shift} \PYG{o}{\textbar{}}       \PYG{n}{ppm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{B0}    \PYG{o}{\textbar{}}         \PYG{n}{T} \PYG{p}{:}    \PYG{l+m+mf}{18.790}
\PYG{n}{temp}  \PYG{o}{\textbar{}}         \PYG{n}{K} \PYG{p}{:}   \PYG{l+m+mf}{298.150}
\PYG{n}{t1e}   \PYG{o}{\textbar{}}        \PYG{n}{ps} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\end{sphinxVerbatim}

\sphinxstyleemphasis{Correlation Plot}

{[}\sphinxcode{\sphinxupquote{pcs\_fit\_multiple.png}}{]}

\noindent\sphinxincludegraphics{{pcs_fit_multiple}.png}


\subsubsection{Fit Tensor to PDB with Models}
\label{\detokenize{examples/pcs_fit_models:fit-tensor-to-pdb-with-models}}\label{\detokenize{examples/pcs_fit_models:pcs-fit-models}}\label{\detokenize{examples/pcs_fit_models::doc}}
This example shows how to fit a \({\Delta\chi}\)-tensor to experimental PCS data using an NMR structure that contains many models. The tensor can be fit to ensemble averaged PCS values, or to individual models. An ensemble averaged PCS is the mean calculated PCS of all models. No structural averages are ever taken.

Data for calbindin D9k are used as in the previous example {\hyperref[\detokenize{examples/pcs_fit:pcs-fit}]{\sphinxcrossref{\DUrole{std,std-ref}{Fit Tensor to PCS Data}}}}.


\paragraph{Downloads}
\label{\detokenize{examples/pcs_fit_models:downloads}}\begin{itemize}
\item {} 
Download the data files \sphinxcode{\sphinxupquote{2bcb.pdb}} and \sphinxcode{\sphinxupquote{calbindin\_Er\_HN\_PCS.npc}} from \sphinxhref{https://github.com/henryorton/paramagpy/tree/master/examples/data\_files/}{here}:

\item {} 
Download the script \sphinxcode{\sphinxupquote{pcs\_fit\_models.py}}

\end{itemize}


\paragraph{Script + Explanation}
\label{\detokenize{examples/pcs_fit_models:script-explanation}}
Firstly, the standard preamble and loading of data.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{paramagpy} \PYG{k}{import} \PYG{n}{protein}\PYG{p}{,} \PYG{n}{fit}\PYG{p}{,} \PYG{n}{dataparse}\PYG{p}{,} \PYG{n}{metal}

\PYG{c+c1}{\PYGZsh{} Load data}
\PYG{n}{prot} \PYG{o}{=} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{load\PYGZus{}pdb}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/2bcb.pdb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{rawData} \PYG{o}{=} \PYG{n}{dataparse}\PYG{o}{.}\PYG{n}{read\PYGZus{}pcs}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/calbindin\PYGZus{}Er\PYGZus{}HN\PYGZus{}PCS.npc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{mStart} \PYG{o}{=} \PYG{n}{metal}\PYG{o}{.}\PYG{n}{Metal}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{mStart}\PYG{o}{.}\PYG{n}{position} \PYG{o}{=} \PYG{n}{prot}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{56}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{CA}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{position}
\end{sphinxVerbatim}

The default method of fitting is to minimise the difference to the experimental values of the ensemble average of the calculated values. The default behaviour is to average atoms with the same serial number in the PDB file. To manipulate ensemble averaging, you can specify the \sphinxcode{\sphinxupquote{sumIndices}} argument of any fitting function such as {\hyperref[\detokenize{reference/generated/paramagpy.fit.nlr_fit_metal_from_pcs:paramagpy.fit.nlr_fit_metal_from_pcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.fit.nlr\_fit\_metal\_from\_pcs()}}}}}. This array contains common integers for corresponding atoms to be averaged. To remove ensemble averaging completely, just specify a list of unique integers with length equal to the data such as \sphinxcode{\sphinxupquote{sumIndices=list(range(len(parsedData)))}}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{} Ensemble average fitting \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{n}{parsedData} \PYG{o}{=} \PYG{n}{prot}\PYG{o}{.}\PYG{n}{parse}\PYG{p}{(}\PYG{n}{rawData}\PYG{p}{)}
\PYG{n}{mGuess}\PYG{p}{,} \PYG{n}{\PYGZus{}}\PYG{p}{,} \PYG{n}{\PYGZus{}} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{svd\PYGZus{}gridsearch\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pcs}\PYG{p}{(}
	\PYG{p}{[}\PYG{n}{mStart}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{n}{parsedData}\PYG{p}{]}\PYG{p}{,} \PYG{n}{radius}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{points}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{n}{mFit}\PYG{p}{,} \PYG{n}{calc}\PYG{p}{,} \PYG{n}{qfac} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{nlr\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pcs}\PYG{p}{(}\PYG{n}{mGuess}\PYG{p}{,} \PYG{p}{[}\PYG{n}{parsedData}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{mFit}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{calbindin\PYGZus{}Er\PYGZus{}HN\PYGZus{}PCS\PYGZus{}tensor\PYGZus{}ensemble.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

If desired, you can also fit a separate tensor to each model of the PDB and the compare them. In this case, we loop over each model, fit a tensor, then keep the one with the smallest Q-factor. Selected models can be parsed by specifying the \sphinxcode{\sphinxupquote{models}} argument of {\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.parse:paramagpy.protein.CustomStructure.parse}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.protein.CustomStructure.parse()}}}}}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{} Single model fitting \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} Loop over models, fit tensor and keep one with best Q\PYGZhy{}factor}
\PYG{n}{minQfacMod} \PYG{o}{=} \PYG{l+m+mf}{1E50}
\PYG{k}{for} \PYG{n}{model} \PYG{o+ow}{in} \PYG{n}{prot}\PYG{p}{:}
	\PYG{n}{parsedDataMod} \PYG{o}{=} \PYG{n}{prot}\PYG{o}{.}\PYG{n}{parse}\PYG{p}{(}\PYG{n}{rawData}\PYG{p}{,} \PYG{n}{models}\PYG{o}{=}\PYG{n}{model}\PYG{o}{.}\PYG{n}{id}\PYG{p}{)}
	\PYG{n}{mFitMod}\PYG{p}{,} \PYG{n}{calcMod}\PYG{p}{,} \PYG{n}{qfacMod} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{nlr\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pcs}\PYG{p}{(}
		\PYG{n}{mGuess}\PYG{p}{,} \PYG{p}{[}\PYG{n}{parsedDataMod}\PYG{p}{]}\PYG{p}{)}
	\PYG{k}{if} \PYG{n}{qfacMod}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{n}{minQfacMod}\PYG{p}{:}
		\PYG{n}{minMod} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{id}
		\PYG{n}{minParsedDataMod} \PYG{o}{=} \PYG{n}{parsedDataMod}
		\PYG{n}{minmFitMod} \PYG{o}{=} \PYG{n}{mFitMod}
		\PYG{n}{mincalcMod} \PYG{o}{=} \PYG{n}{calcMod}
		\PYG{n}{minQfacMod} \PYG{o}{=} \PYG{n}{qfacMod}
\end{sphinxVerbatim}

Finally we plot three sets of data:
\begin{itemize}
\item {} 
The ensemble average fit calculated for each model (green)

\item {} 
The ensemble average of the calculated values of the ensemble fit (red)

\item {} 
The best fitting single model (blue)

\end{itemize}

Note that to calculate the ensemble average of the calculated values we use the function {\hyperref[\detokenize{reference/generated/paramagpy.fit.ensemble_average:paramagpy.fit.ensemble_average}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.fit.ensemble\_average()}}}}}. This can take any number of arguments, and will average values based on common serial numbers of the list of atoms in the first argument.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{} Plot the correlation \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{k+kn}{from} \PYG{n+nn}{matplotlib} \PYG{k}{import} \PYG{n}{pyplot} \PYG{k}{as} \PYG{n}{plt}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Unpack the experimental values}
\PYG{n}{atoms}\PYG{p}{,} \PYG{n}{exp}\PYG{p}{,} \PYG{n}{err} \PYG{o}{=} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{o}{*}\PYG{n}{parsedData}\PYG{p}{)}
\PYG{n}{expEnsemble}\PYG{p}{,} \PYG{n}{calcEnsemble} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{ensemble\PYGZus{}average}\PYG{p}{(}\PYG{n}{atoms}\PYG{p}{,} \PYG{n}{exp}\PYG{p}{,} \PYG{n}{calc}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{atomsMod}\PYG{p}{,} \PYG{n}{expMod}\PYG{p}{,} \PYG{n}{errMod} \PYG{o}{=} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{o}{*}\PYG{n}{minParsedDataMod}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot all models}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{exp}\PYG{p}{,} \PYG{n}{calc}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ms}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{g}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
	\PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{All models: Q = }\PYG{l+s+si}{\PYGZob{}:5.4f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{qfac}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot the ensemble average}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{expEnsemble}\PYG{p}{,} \PYG{n}{calcEnsemble}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ms}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
	\PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Ensemble Average: Q = }\PYG{l+s+si}{\PYGZob{}:5.4f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{qfac}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot the model with minimum Q\PYGZhy{}factor}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{expMod}\PYG{p}{,} \PYG{n}{mincalcMod}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ms}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
	\PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Best Model (}\PYG{l+s+si}{\PYGZob{}0:\PYGZcb{}}\PYG{l+s+s2}{): Q = }\PYG{l+s+si}{\PYGZob{}1:5.4f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}
		\PYG{n}{minMod}\PYG{p}{,} \PYG{n}{minQfacMod}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot a diagonal}
\PYG{n}{l}\PYG{p}{,} \PYG{n}{h} \PYG{o}{=} \PYG{n}{ax}\PYG{o}{.}\PYG{n}{get\PYGZus{}xlim}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}k}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlim}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Make axis labels and save figure}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Experiment}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Calculated}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pcs\PYGZus{}fit\PYGZus{}models.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{pcs\_fit\_models.png}}{]}

\noindent\sphinxincludegraphics{{pcs_fit_models}.png}


\subsubsection{Constrained Fitting}
\label{\detokenize{examples/pcs_fit_constrained:constrained-fitting}}\label{\detokenize{examples/pcs_fit_constrained:pcs-fit-constrained}}\label{\detokenize{examples/pcs_fit_constrained::doc}}
This example shows how to fit a \({\Delta\chi}\)-tensor with constraints applied. The two cases here constrain position to fit a tensor to a known metal ion position form an X-ray structure, and fit an axially symmetric tensor with only 6 of the usual 8 parameters.


\paragraph{Downloads}
\label{\detokenize{examples/pcs_fit_constrained:downloads}}\begin{itemize}
\item {} 
Download the data files \sphinxcode{\sphinxupquote{4icbH\_mut.pdb}} and \sphinxcode{\sphinxupquote{calbindin\_Er\_HN\_PCS.npc}} from \sphinxhref{https://github.com/henryorton/paramagpy/tree/master/examples/data\_files/}{here}:

\item {} 
Download the script \sphinxcode{\sphinxupquote{pcs\_fit\_constrained.py}}

\end{itemize}


\paragraph{Script + Explanation}
\label{\detokenize{examples/pcs_fit_constrained:script-explanation}}
The necessary modules are imported and data is loaded

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{paramagpy} \PYG{k}{import} \PYG{n}{protein}\PYG{p}{,} \PYG{n}{fit}\PYG{p}{,} \PYG{n}{dataparse}\PYG{p}{,} \PYG{n}{metal}

\PYG{c+c1}{\PYGZsh{} Load data}
\PYG{n}{prot} \PYG{o}{=} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{load\PYGZus{}pdb}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/4icbH\PYGZus{}mut.pdb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{rawData} \PYG{o}{=} \PYG{n}{dataparse}\PYG{o}{.}\PYG{n}{read\PYGZus{}pcs}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/calbindin\PYGZus{}Er\PYGZus{}HN\PYGZus{}PCS.npc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{parsedData} \PYG{o}{=} \PYG{n}{prot}\PYG{o}{.}\PYG{n}{parse}\PYG{p}{(}\PYG{n}{rawData}\PYG{p}{)}
\PYG{n}{mStart} \PYG{o}{=} \PYG{n}{metal}\PYG{o}{.}\PYG{n}{Metal}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

The calcium ion from the X-ray structure is contained in a heteroatom of the PDB file. We set the starting position of the tensor to this position.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Set the starting position to Calcium ion heteroatom in PDB}
\PYG{n}{mStart}\PYG{o}{.}\PYG{n}{position} \PYG{o}{=} \PYG{n}{prot}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H\PYGZus{} CA}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{77}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{CA}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{position}
\end{sphinxVerbatim}

To fit the the anisotropy and orientation without position, the linear PCS equation can be solved analytically by the SVD gridsearch method but using only one point with a radius of zero. This tensor is then saved.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Calculate tensor by SVD}
\PYG{n}{mFit}\PYG{p}{,} \PYG{n}{calc}\PYG{p}{,} \PYG{n}{qfac} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{svd\PYGZus{}gridsearch\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pcs}\PYG{p}{(}
	\PYG{p}{[}\PYG{n}{mStart}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{n}{parsedData}\PYG{p}{]}\PYG{p}{,} \PYG{n}{radius}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{points}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{n}{mFit}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{calbindin\PYGZus{}Er\PYGZus{}HN\PYGZus{}PCS\PYGZus{}tensor\PYGZus{}position\PYGZus{}constrained.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{pcs\_fit\_constrained.png}}{]}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ax}    \PYG{o}{\textbar{}} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{8.152}
\PYG{n}{rh}    \PYG{o}{\textbar{}} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.911}
\PYG{n}{x}     \PYG{o}{\textbar{}}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}    \PYG{l+m+mf}{25.786}
\PYG{n}{y}     \PYG{o}{\textbar{}}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{9.515}
\PYG{n}{z}     \PYG{o}{\textbar{}}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{6.558}
\PYG{n}{a}     \PYG{o}{\textbar{}}       \PYG{n}{deg} \PYG{p}{:}   \PYG{l+m+mf}{125.841}
\PYG{n}{b}     \PYG{o}{\textbar{}}       \PYG{n}{deg} \PYG{p}{:}   \PYG{l+m+mf}{142.287}
\PYG{n}{g}     \PYG{o}{\textbar{}}       \PYG{n}{deg} \PYG{p}{:}    \PYG{l+m+mf}{41.758}
\PYG{n}{mueff} \PYG{o}{\textbar{}}        \PYG{n}{Bm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{shift} \PYG{o}{\textbar{}}       \PYG{n}{ppm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{B0}    \PYG{o}{\textbar{}}         \PYG{n}{T} \PYG{p}{:}    \PYG{l+m+mf}{18.790}
\PYG{n}{temp}  \PYG{o}{\textbar{}}         \PYG{n}{K} \PYG{p}{:}   \PYG{l+m+mf}{298.150}
\PYG{n}{t1e}   \PYG{o}{\textbar{}}        \PYG{n}{ps} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\end{sphinxVerbatim}

To fit an axially symmetric tensor, we can used the Non-linear regression method and specify exactly which parameters we want to fit. This will be the axiality \sphinxcode{\sphinxupquote{ax}}, two Euler angles \sphinxcode{\sphinxupquote{b}} and \sphinxcode{\sphinxupquote{g}} and the position coordinates. Note that in the output, the rhombic \sphinxcode{\sphinxupquote{rh}} and alpha \sphinxcode{\sphinxupquote{a}} parameters are redundant.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Calculate axially symmetric tensor by NRL}
\PYG{n}{mFitAx}\PYG{p}{,} \PYG{n}{calcAx}\PYG{p}{,} \PYG{n}{qfacAx} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{nlr\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pcs}\PYG{p}{(}
	\PYG{p}{[}\PYG{n}{mStart}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{parsedData}\PYG{p}{]}\PYG{p}{,} \PYG{n}{params}\PYG{o}{=}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ax}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{g}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{mFitAx}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{calbindin\PYGZus{}Er\PYGZus{}HN\PYGZus{}PCS\PYGZus{}tensor\PYGZus{}axially\PYGZus{}symmetric.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{pcs\_fit\_constrained.png}}{]}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ax}    \PYG{o}{\textbar{}} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}     \PYG{l+m+mf}{9.510}
\PYG{n}{rh}    \PYG{o}{\textbar{}} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{x}     \PYG{o}{\textbar{}}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}    \PYG{l+m+mf}{24.948}
\PYG{n}{y}     \PYG{o}{\textbar{}}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{8.992}
\PYG{n}{z}     \PYG{o}{\textbar{}}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{3.205}
\PYG{n}{a}     \PYG{o}{\textbar{}}       \PYG{n}{deg} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{b}     \PYG{o}{\textbar{}}       \PYG{n}{deg} \PYG{p}{:}   \PYG{l+m+mf}{134.697}
\PYG{n}{g}     \PYG{o}{\textbar{}}       \PYG{n}{deg} \PYG{p}{:}   \PYG{l+m+mf}{180.000}
\PYG{n}{mueff} \PYG{o}{\textbar{}}        \PYG{n}{Bm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{shift} \PYG{o}{\textbar{}}       \PYG{n}{ppm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{B0}    \PYG{o}{\textbar{}}         \PYG{n}{T} \PYG{p}{:}    \PYG{l+m+mf}{18.790}
\PYG{n}{temp}  \PYG{o}{\textbar{}}         \PYG{n}{K} \PYG{p}{:}   \PYG{l+m+mf}{298.150}
\PYG{n}{t1e}   \PYG{o}{\textbar{}}        \PYG{n}{ps} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\end{sphinxVerbatim}

Finally we plot the data.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{} Plot the correlation \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{k+kn}{from} \PYG{n+nn}{matplotlib} \PYG{k}{import} \PYG{n}{pyplot} \PYG{k}{as} \PYG{n}{plt}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Unpack the experimental values}
\PYG{n}{atoms}\PYG{p}{,} \PYG{n}{experiment}\PYG{p}{,} \PYG{n}{errors} \PYG{o}{=} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{o}{*}\PYG{n}{parsedData}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot the data}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{experiment}\PYG{p}{,} \PYG{n}{calc}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ms}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
	\PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Position constrained: Q = }\PYG{l+s+si}{\PYGZob{}:5.4f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{qfac}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{experiment}\PYG{p}{,} \PYG{n}{calcAx}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ms}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
	\PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Axially symmetric: Q = }\PYG{l+s+si}{\PYGZob{}:5.4f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{qfacAx}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot a diagonal}
\PYG{n}{l}\PYG{p}{,} \PYG{n}{h} \PYG{o}{=} \PYG{n}{ax}\PYG{o}{.}\PYG{n}{get\PYGZus{}xlim}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}k}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlim}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Make axis labels and save figure}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Experiment}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Calculated}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pcs\PYGZus{}fit\PYGZus{}constrained.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{pcs\_fit\_constrained.png}}{]}

\noindent\sphinxincludegraphics{{pcs_fit_constrained}.png}


\subsubsection{Fit a tensor to PCS data with uncertainties}
\label{\detokenize{examples/pcs_fit_error:fit-a-tensor-to-pcs-data-with-uncertainties}}\label{\detokenize{examples/pcs_fit_error:pcs-fit-error}}\label{\detokenize{examples/pcs_fit_error::doc}}
This example shows how to conduct a weighted fit of a \({\Delta\chi}\)-tensor to experimental PCS data with experimental errors.


\paragraph{Downloads}
\label{\detokenize{examples/pcs_fit_error:downloads}}\begin{itemize}
\item {} 
Download the data files \sphinxcode{\sphinxupquote{4icbH\_mut.pdb}} and \sphinxcode{\sphinxupquote{calbindin\_Er\_HN\_PCS\_errors.npc}} from \sphinxhref{https://github.com/henryorton/paramagpy/tree/master/examples/data\_files/}{here}:

\item {} 
Download the script \sphinxcode{\sphinxupquote{pcs\_fit\_error.py}}

\end{itemize}


\paragraph{Script + Explanation}
\label{\detokenize{examples/pcs_fit_error:script-explanation}}
This script follows very closely the script {\hyperref[\detokenize{examples/pcs_fit:pcs-fit}]{\sphinxcrossref{\DUrole{std,std-ref}{Fit Tensor to PCS Data}}}}. The only difference being that errors are included in the fourth column of the .npc file and errorbars are included in the plotting routine.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{paramagpy} \PYG{k}{import} \PYG{n}{protein}\PYG{p}{,} \PYG{n}{fit}\PYG{p}{,} \PYG{n}{dataparse}\PYG{p}{,} \PYG{n}{metal}

\PYG{c+c1}{\PYGZsh{} Load the PDB file}
\PYG{n}{prot} \PYG{o}{=} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{load\PYGZus{}pdb}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/4icbH\PYGZus{}mut.pdb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Load the PCS data}
\PYG{n}{rawData} \PYG{o}{=} \PYG{n}{dataparse}\PYG{o}{.}\PYG{n}{read\PYGZus{}pcs}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/calbindin\PYGZus{}Er\PYGZus{}HN\PYGZus{}PCS\PYGZus{}errors.npc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Associate PCS data with atoms of the PDB}
\PYG{n}{parsedData} \PYG{o}{=} \PYG{n}{prot}\PYG{o}{.}\PYG{n}{parse}\PYG{p}{(}\PYG{n}{rawData}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Define an initial tensor}
\PYG{n}{mStart} \PYG{o}{=} \PYG{n}{metal}\PYG{o}{.}\PYG{n}{Metal}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Set the starting position to an atom close to the metal}
\PYG{n}{mStart}\PYG{o}{.}\PYG{n}{position} \PYG{o}{=} \PYG{n}{prot}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{56}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{CA}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{position}

\PYG{c+c1}{\PYGZsh{} Calculate an initial tensor from an SVD gridsearch}
\PYG{n}{mGuess}\PYG{p}{,} \PYG{n}{calc}\PYG{p}{,} \PYG{n}{qfac} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{svd\PYGZus{}gridsearch\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pcs}\PYG{p}{(}
	\PYG{p}{[}\PYG{n}{mStart}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{n}{parsedData}\PYG{p}{]}\PYG{p}{,} \PYG{n}{radius}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{points}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Refine the tensor using non\PYGZhy{}linear regression}
\PYG{n}{mFit}\PYG{p}{,} \PYG{n}{calc}\PYG{p}{,} \PYG{n}{qfac} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{nlr\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pcs}\PYG{p}{(}\PYG{n}{mGuess}\PYG{p}{,} \PYG{p}{[}\PYG{n}{parsedData}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Save the fitted tensor to file}
\PYG{n}{mFit}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{calbindin\PYGZus{}Er\PYGZus{}HN\PYGZus{}PCS\PYGZus{}tensor\PYGZus{}errors.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{} Plot the correlation \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{k+kn}{from} \PYG{n+nn}{matplotlib} \PYG{k}{import} \PYG{n}{pyplot} \PYG{k}{as} \PYG{n}{plt}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Unpack the experimental values}
\PYG{n}{atoms}\PYG{p}{,} \PYG{n}{experiment}\PYG{p}{,} \PYG{n}{errors} \PYG{o}{=} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{o}{*}\PYG{n}{parsedData}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot the data}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{errorbar}\PYG{p}{(}\PYG{n}{experiment}\PYG{p}{,} \PYG{n}{calc}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{xerr}\PYG{o}{=}\PYG{n}{errors}\PYG{p}{,} \PYG{n}{fmt}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ms}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} 
	\PYG{n}{ecolor}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{k}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{capsize}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q\PYGZhy{}factor = }\PYG{l+s+si}{\PYGZob{}:5.4f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{qfac}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot a diagonal}
\PYG{n}{l}\PYG{p}{,} \PYG{n}{h} \PYG{o}{=} \PYG{n}{ax}\PYG{o}{.}\PYG{n}{get\PYGZus{}xlim}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{grey}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlim}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Make axis labels and save figure}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Experiment}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Calculated}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pcs\PYGZus{}fit\PYGZus{}error.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

The fitted tensor:

\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{calbindin\_Er\_HN\_PCS\_tensor\_errors.txt}}{]}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ax}    \PYG{o}{\textbar{}} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{8.012}
\PYG{n}{rh}    \PYG{o}{\textbar{}} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.125}
\PYG{n}{x}     \PYG{o}{\textbar{}}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}    \PYG{l+m+mf}{24.892}
\PYG{n}{y}     \PYG{o}{\textbar{}}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{8.456}
\PYG{n}{z}     \PYG{o}{\textbar{}}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{6.287}
\PYG{n}{a}     \PYG{o}{\textbar{}}       \PYG{n}{deg} \PYG{p}{:}   \PYG{l+m+mf}{112.440}
\PYG{n}{b}     \PYG{o}{\textbar{}}       \PYG{n}{deg} \PYG{p}{:}   \PYG{l+m+mf}{135.924}
\PYG{n}{g}     \PYG{o}{\textbar{}}       \PYG{n}{deg} \PYG{p}{:}    \PYG{l+m+mf}{46.210}
\PYG{n}{mueff} \PYG{o}{\textbar{}}        \PYG{n}{Bm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{shift} \PYG{o}{\textbar{}}       \PYG{n}{ppm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{B0}    \PYG{o}{\textbar{}}         \PYG{n}{T} \PYG{p}{:}    \PYG{l+m+mf}{18.790}
\PYG{n}{temp}  \PYG{o}{\textbar{}}         \PYG{n}{K} \PYG{p}{:}   \PYG{l+m+mf}{298.150}
\PYG{n}{t1e}   \PYG{o}{\textbar{}}        \PYG{n}{ps} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{taur}  \PYG{o}{\textbar{}}        \PYG{n}{ns} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\end{sphinxVerbatim}

And correlation plot:

\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{pcs\_fit\_error.png}}{]}

\noindent\sphinxincludegraphics{{pcs_fit_error}.png}


\subsubsection{Fit to PCS data with offset, RACS and RADS corrections}
\label{\detokenize{examples/pcs_fit_advanced_corrections:fit-to-pcs-data-with-offset-racs-and-rads-corrections}}\label{\detokenize{examples/pcs_fit_advanced_corrections:pcs-fit-advanced-corrections}}\label{\detokenize{examples/pcs_fit_advanced_corrections::doc}}

\subsection{RDC data}
\label{\detokenize{examples/index:rdc-data}}

\subsubsection{Fit Tensor to RDC Data}
\label{\detokenize{examples/rdc_fit:fit-tensor-to-rdc-data}}\label{\detokenize{examples/rdc_fit:rdc-fit}}\label{\detokenize{examples/rdc_fit::doc}}
This example shows how to fit a \({\Delta\chi}\)-tensor or equivalently, and alignment tensor to experimental RDC data. These data are taken from a Tb3+ tagged ubiquitin mutant:

Benjamin J. G. Pearce, Shereen Jabar, Choy-Theng Loh, Monika Szabo, Bim Graham, Gottfried Otting (2017) Structure restraints from heteronuclear pseudocontact shifts generated by lanthanide tags at two different sites \sphinxstyleemphasis{J. Biomol. NMR} 68:19-32


\paragraph{Downloads}
\label{\detokenize{examples/rdc_fit:downloads}}\begin{itemize}
\item {} 
Download the data files \sphinxcode{\sphinxupquote{2kox.pdb}}, \sphinxcode{\sphinxupquote{ubiquitin\_a28c\_c1\_Tb\_HN.rdc}} and \sphinxcode{\sphinxupquote{ubiquitin\_s57c\_c1\_Tb\_HN.rdc}} from \sphinxhref{https://github.com/henryorton/paramagpy/tree/master/examples/data\_files/}{here}:

\item {} 
Download the script \sphinxcode{\sphinxupquote{rdc\_fit.py}}

\end{itemize}


\paragraph{Script + Explanation}
\label{\detokenize{examples/rdc_fit:script-explanation}}
Firstly, the necessary modules are imported from paramagpy. And the two RDC datasets are loaded. Because this PDB contains over 600 models, loading may take a few seconds

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{paramagpy} \PYG{k}{import} \PYG{n}{protein}\PYG{p}{,} \PYG{n}{fit}\PYG{p}{,} \PYG{n}{dataparse}\PYG{p}{,} \PYG{n}{metal}

\PYG{c+c1}{\PYGZsh{} Load the PDB file}
\PYG{n}{prot} \PYG{o}{=} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{load\PYGZus{}pdb}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/2kox.pdb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Load the RDC data}
\PYG{n}{rawData1} \PYG{o}{=} \PYG{n}{dataparse}\PYG{o}{.}\PYG{n}{read\PYGZus{}rdc}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/ubiquitin\PYGZus{}a28c\PYGZus{}c1\PYGZus{}Tb\PYGZus{}HN.rdc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{rawData2} \PYG{o}{=} \PYG{n}{dataparse}\PYG{o}{.}\PYG{n}{read\PYGZus{}rdc}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/ubiquitin\PYGZus{}s57c\PYGZus{}c1\PYGZus{}Tb\PYGZus{}HN.rdc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Associate RDC data with atoms of the PDB}
\PYG{n}{parsedData1} \PYG{o}{=} \PYG{n}{prot}\PYG{o}{.}\PYG{n}{parse}\PYG{p}{(}\PYG{n}{rawData1}\PYG{p}{)}
\PYG{n}{parsedData2} \PYG{o}{=} \PYG{n}{prot}\PYG{o}{.}\PYG{n}{parse}\PYG{p}{(}\PYG{n}{rawData2}\PYG{p}{)}
\end{sphinxVerbatim}

Two starting metals are initialised. It is important here to set the magnetic field strength and temperature.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Define an initial tensor}
\PYG{n}{mStart1} \PYG{o}{=} \PYG{n}{metal}\PYG{o}{.}\PYG{n}{Metal}\PYG{p}{(}\PYG{n}{B0}\PYG{o}{=}\PYG{l+m+mf}{18.8}\PYG{p}{,} \PYG{n}{temperature}\PYG{o}{=}\PYG{l+m+mf}{308.0}\PYG{p}{)}
\PYG{n}{mStart2} \PYG{o}{=} \PYG{n}{metal}\PYG{o}{.}\PYG{n}{Metal}\PYG{p}{(}\PYG{n}{B0}\PYG{o}{=}\PYG{l+m+mf}{18.8}\PYG{p}{,} \PYG{n}{temperature}\PYG{o}{=}\PYG{l+m+mf}{308.0}\PYG{p}{)}
\end{sphinxVerbatim}

The alignment tensor is solved using the function {\hyperref[\detokenize{reference/generated/paramagpy.fit.svd_fit_metal_from_rdc:paramagpy.fit.svd_fit_metal_from_rdc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.fit.svd\_fit\_metal\_from\_rdc()}}}}} which return a tuple of \sphinxcode{\sphinxupquote{(metal, calculated, qfactor)}}, where metal is the fitted metal, calculated is the calculated RDC values. These tensor are then saved.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Calculate the tensor using SVD}
\PYG{n}{sol1} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{svd\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}rdc}\PYG{p}{(}\PYG{n}{mStart1}\PYG{p}{,} \PYG{n}{parsedData1}\PYG{p}{)}
\PYG{n}{sol2} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{svd\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}rdc}\PYG{p}{(}\PYG{n}{mStart2}\PYG{p}{,} \PYG{n}{parsedData2}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Save the fitted tensor to file}
\PYG{n}{sol1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ubiquitin\PYGZus{}a28c\PYGZus{}c1\PYGZus{}Tb\PYGZus{}tensor.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{sol2}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ubiquitin\PYGZus{}s57c\PYGZus{}c1\PYGZus{}Tb\PYGZus{}tensor.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{ubiquitin\_a28c\_c1\_Tb\_tensor.txt}}{]}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ax}    \PYG{o}{\textbar{}} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.776}
\PYG{n}{rh}    \PYG{o}{\textbar{}} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.397}
\PYG{n}{x}     \PYG{o}{\textbar{}}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{y}     \PYG{o}{\textbar{}}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{z}     \PYG{o}{\textbar{}}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{a}     \PYG{o}{\textbar{}}       \PYG{n}{deg} \PYG{p}{:}    \PYG{l+m+mf}{16.022}
\PYG{n}{b}     \PYG{o}{\textbar{}}       \PYG{n}{deg} \PYG{p}{:}    \PYG{l+m+mf}{52.299}
\PYG{n}{g}     \PYG{o}{\textbar{}}       \PYG{n}{deg} \PYG{p}{:}    \PYG{l+m+mf}{83.616}
\PYG{n}{mueff} \PYG{o}{\textbar{}}        \PYG{n}{Bm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{shift} \PYG{o}{\textbar{}}       \PYG{n}{ppm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{B0}    \PYG{o}{\textbar{}}         \PYG{n}{T} \PYG{p}{:}    \PYG{l+m+mf}{18.800}
\PYG{n}{temp}  \PYG{o}{\textbar{}}         \PYG{n}{K} \PYG{p}{:}   \PYG{l+m+mf}{308.000}
\PYG{n}{t1e}   \PYG{o}{\textbar{}}        \PYG{n}{ps} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{taur}  \PYG{o}{\textbar{}}        \PYG{n}{ns} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\end{sphinxVerbatim}

\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{ubiquitin\_s57c\_c1\_Tb\_tensor.txt}}{]}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ax}    \PYG{o}{\textbar{}} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.930}
\PYG{n}{rh}    \PYG{o}{\textbar{}} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.899}
\PYG{n}{x}     \PYG{o}{\textbar{}}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{y}     \PYG{o}{\textbar{}}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{z}     \PYG{o}{\textbar{}}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{a}     \PYG{o}{\textbar{}}       \PYG{n}{deg} \PYG{p}{:}     \PYG{l+m+mf}{9.976}
\PYG{n}{b}     \PYG{o}{\textbar{}}       \PYG{n}{deg} \PYG{p}{:}    \PYG{l+m+mf}{99.463}
\PYG{n}{g}     \PYG{o}{\textbar{}}       \PYG{n}{deg} \PYG{p}{:}    \PYG{l+m+mf}{37.410}
\PYG{n}{mueff} \PYG{o}{\textbar{}}        \PYG{n}{Bm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{shift} \PYG{o}{\textbar{}}       \PYG{n}{ppm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{B0}    \PYG{o}{\textbar{}}         \PYG{n}{T} \PYG{p}{:}    \PYG{l+m+mf}{18.800}
\PYG{n}{temp}  \PYG{o}{\textbar{}}         \PYG{n}{K} \PYG{p}{:}   \PYG{l+m+mf}{308.000}
\PYG{n}{t1e}   \PYG{o}{\textbar{}}        \PYG{n}{ps} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{taur}  \PYG{o}{\textbar{}}        \PYG{n}{ns} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\end{sphinxVerbatim}

The experimental/calculated correlations are then plotted. The tensor is by default fitted to the ensemble averaged calculated values. Backcalculation of all models is shown here, as well as the ensemble average.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{} Plot the correlation \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{k+kn}{from} \PYG{n+nn}{matplotlib} \PYG{k}{import} \PYG{n}{pyplot} \PYG{k}{as} \PYG{n}{plt}
\PYG{n}{fig} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{ax1} \PYG{o}{=} \PYG{n}{fig}\PYG{o}{.}\PYG{n}{add\PYGZus{}subplot}\PYG{p}{(}\PYG{l+m+mi}{211}\PYG{p}{)}
\PYG{n}{ax2} \PYG{o}{=} \PYG{n}{fig}\PYG{o}{.}\PYG{n}{add\PYGZus{}subplot}\PYG{p}{(}\PYG{l+m+mi}{212}\PYG{p}{)}
\PYG{n}{ax1}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A28C\PYGZhy{}C1\PYGZhy{}Tb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax2}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{S57C\PYGZhy{}C1\PYGZhy{}Tb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{sol}\PYG{p}{,} \PYG{n}{ax}\PYG{p}{,} \PYG{n}{pdata} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{p}{[}\PYG{n}{sol1}\PYG{p}{,}\PYG{n}{sol2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{ax1}\PYG{p}{,}\PYG{n}{ax2}\PYG{p}{]}\PYG{p}{,} 
	\PYG{p}{[}\PYG{n}{parsedData1}\PYG{p}{,}\PYG{n}{parsedData2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}

	\PYG{c+c1}{\PYGZsh{} Unpack the experimental values}
	\PYG{n}{atoms1}\PYG{p}{,} \PYG{n}{atoms2}\PYG{p}{,} \PYG{n}{exp}\PYG{p}{,} \PYG{n}{err} \PYG{o}{=} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{o}{*}\PYG{n}{pdata}\PYG{p}{)}
	\PYG{n}{atoms} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{atoms1}\PYG{p}{,} \PYG{n}{atoms2}\PYG{p}{)}\PYG{p}{)}
	\PYG{n}{metal}\PYG{p}{,} \PYG{n}{calc}\PYG{p}{,} \PYG{n}{qfac} \PYG{o}{=} \PYG{n}{sol}
	\PYG{n}{expEnsemble}\PYG{p}{,} \PYG{n}{calcEnsemble} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{ensemble\PYGZus{}average}\PYG{p}{(}\PYG{n}{atoms}\PYG{p}{,} \PYG{n}{exp}\PYG{p}{,} \PYG{n}{calc}\PYG{p}{)}

	\PYG{c+c1}{\PYGZsh{} Plot all models}
	\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{exp}\PYG{p}{,} \PYG{n}{calc}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ms}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
		\PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{All models: Q = }\PYG{l+s+si}{\PYGZob{}:5.4f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{qfac}\PYG{p}{)}\PYG{p}{)}

	\PYG{c+c1}{\PYGZsh{} Plot the ensemble average}
	\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{expEnsemble}\PYG{p}{,} \PYG{n}{calcEnsemble}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ms}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
		\PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Ensemble Average: Q = }\PYG{l+s+si}{\PYGZob{}:5.4f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{qfac}\PYG{p}{)}\PYG{p}{)}

	\PYG{c+c1}{\PYGZsh{} Plot a diagonal}
	\PYG{n}{l}\PYG{p}{,} \PYG{n}{h} \PYG{o}{=} \PYG{n}{ax}\PYG{o}{.}\PYG{n}{get\PYGZus{}xlim}\PYG{p}{(}\PYG{p}{)}
	\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}k}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
	\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlim}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}
	\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}

	\PYG{c+c1}{\PYGZsh{} Make axis labels and save figure}
	\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Experiment}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
	\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Calculated}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
	\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{fig}\PYG{o}{.}\PYG{n}{tight\PYGZus{}layout}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{rdc\PYGZus{}fit.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{rdc\_fit.png}}{]}

\noindent\sphinxincludegraphics{{rdc_fit}.png}


\subsubsection{Calculate RDC from a known Tensor}
\label{\detokenize{examples/rdc_calculate:calculate-rdc-from-a-known-tensor}}\label{\detokenize{examples/rdc_calculate:rdc-calculate}}\label{\detokenize{examples/rdc_calculate::doc}}
This example shows how to calculate theoretical RDC values from a known \({\Delta\chi}\)-tensor which has been fitted from PCS data. Paramagpy allows seamless calculation of one PCS/PRE/RDC/CCR effect from a tensor fitted from another effect.


\paragraph{Downloads}
\label{\detokenize{examples/rdc_calculate:downloads}}\begin{itemize}
\item {} 
Download the data files \sphinxcode{\sphinxupquote{4icbH\_mut.pdb}} and \sphinxcode{\sphinxupquote{calbindin\_Er\_HN\_PCS\_tensor.txt}} from \sphinxhref{https://github.com/henryorton/paramagpy/tree/master/examples/data\_files/}{here}:

\item {} 
Download the script \sphinxcode{\sphinxupquote{rdc\_calculate.py}}

\end{itemize}


\paragraph{Script + Explanation}
\label{\detokenize{examples/rdc_calculate:script-explanation}}
First the relevant modules are loaded, the protein is loaded and the metal is loaded from file. The magnetic field strength and temperature are also set.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{paramagpy} \PYG{k}{import} \PYG{n}{protein}\PYG{p}{,} \PYG{n}{metal}

\PYG{c+c1}{\PYGZsh{} Load the PDB file}
\PYG{n}{prot} \PYG{o}{=} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{load\PYGZus{}pdb}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/4icbH\PYGZus{}mut.pdb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Load the fitted tensor}
\PYG{n}{met} \PYG{o}{=} \PYG{n}{metal}\PYG{o}{.}\PYG{n}{load\PYGZus{}tensor}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/calbindin\PYGZus{}Er\PYGZus{}HN\PYGZus{}PCS\PYGZus{}tensor.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{met}\PYG{o}{.}\PYG{n}{B0} \PYG{o}{=} \PYG{l+m+mf}{18.8}
\end{sphinxVerbatim}

A loop is made over the atoms of the protein. The amide H and N atoms are selected and then the RDC value is calculated. Finally the formated data is appended to list \sphinxcode{\sphinxupquote{forFile}}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{forFile} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{atom} \PYG{o+ow}{in} \PYG{n}{prot}\PYG{o}{.}\PYG{n}{get\PYGZus{}atoms}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
	\PYG{k}{if} \PYG{n}{atom}\PYG{o}{.}\PYG{n}{name} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
		\PYG{n}{residue} \PYG{o}{=} \PYG{n}{atom}\PYG{o}{.}\PYG{n}{parent}
		\PYG{n}{seq} \PYG{o}{=} \PYG{n}{residue}\PYG{o}{.}\PYG{n}{id}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
		\PYG{k}{if} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{in} \PYG{n}{residue}\PYG{p}{:}
			\PYG{n}{H} \PYG{o}{=} \PYG{n}{atom}
			\PYG{n}{N} \PYG{o}{=} \PYG{n}{residue}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
			\PYG{n}{rdc} \PYG{o}{=} \PYG{n}{met}\PYG{o}{.}\PYG{n}{atom\PYGZus{}rdc}\PYG{p}{(}\PYG{n}{H}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}
			\PYG{n}{line} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}0:2d\PYGZcb{}}\PYG{l+s+s2}{ }\PYG{l+s+si}{\PYGZob{}1:\PYGZca{}3s\PYGZcb{}}\PYG{l+s+s2}{ }\PYG{l+s+si}{\PYGZob{}2:2d\PYGZcb{}}\PYG{l+s+s2}{ }\PYG{l+s+si}{\PYGZob{}3:\PYGZca{}3s\PYGZcb{}}\PYG{l+s+s2}{ }\PYG{l+s+si}{\PYGZob{}4:6.3f\PYGZcb{}}\PYG{l+s+s2}{ 0.0}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}
				\PYG{n}{seq}\PYG{p}{,} \PYG{n}{H}\PYG{o}{.}\PYG{n}{name}\PYG{p}{,} \PYG{n}{seq}\PYG{p}{,} \PYG{n}{N}\PYG{o}{.}\PYG{n}{name}\PYG{p}{,} \PYG{n}{rdc}\PYG{p}{)}
			\PYG{n}{forFile}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}
\end{sphinxVerbatim}

The formatted data is written to file:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{calbindin\PYGZus{}Er\PYGZus{}RDC\PYGZus{}calc.rdc}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{w}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
	\PYG{n}{f}\PYG{o}{.}\PYG{n}{writelines}\PYG{p}{(}\PYG{n}{forFile}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{calbindin\_Er\_RDC\_calc.rdc}}{]}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYG{l+m+mi}{0}  \PYG{n}{H}   \PYG{l+m+mi}{0}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.724} \PYG{l+m+mf}{0.0}
 \PYG{l+m+mi}{1}  \PYG{n}{H}   \PYG{l+m+mi}{1}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.196} \PYG{l+m+mf}{0.0}
 \PYG{l+m+mi}{2}  \PYG{n}{H}   \PYG{l+m+mi}{2}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.993} \PYG{l+m+mf}{0.0}
 \PYG{l+m+mi}{4}  \PYG{n}{H}   \PYG{l+m+mi}{4}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.922} \PYG{l+m+mf}{0.0}
 \PYG{l+m+mi}{5}  \PYG{n}{H}   \PYG{l+m+mi}{5}  \PYG{n}{N}   \PYG{l+m+mf}{1.783} \PYG{l+m+mf}{0.0}
 \PYG{l+m+mi}{6}  \PYG{n}{H}   \PYG{l+m+mi}{6}  \PYG{n}{N}   \PYG{l+m+mf}{0.280} \PYG{l+m+mf}{0.0}
 \PYG{l+m+mi}{7}  \PYG{n}{H}   \PYG{l+m+mi}{7}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.906} \PYG{l+m+mf}{0.0}
 \PYG{l+m+mi}{8}  \PYG{n}{H}   \PYG{l+m+mi}{8}  \PYG{n}{N}   \PYG{l+m+mf}{1.056} \PYG{l+m+mf}{0.0}
 \PYG{l+m+mi}{9}  \PYG{n}{H}   \PYG{l+m+mi}{9}  \PYG{n}{N}   \PYG{l+m+mf}{0.713} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{10}  \PYG{n}{H}  \PYG{l+m+mi}{10}  \PYG{n}{N}   \PYG{l+m+mf}{0.213} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{11}  \PYG{n}{H}  \PYG{l+m+mi}{11}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.881} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{12}  \PYG{n}{H}  \PYG{l+m+mi}{12}  \PYG{n}{N}   \PYG{l+m+mf}{2.712} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{13}  \PYG{n}{H}  \PYG{l+m+mi}{13}  \PYG{n}{N}   \PYG{l+m+mf}{0.614} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{14}  \PYG{n}{H}  \PYG{l+m+mi}{14}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.346} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{15}  \PYG{n}{H}  \PYG{l+m+mi}{15}  \PYG{n}{N}   \PYG{l+m+mf}{1.659} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{16}  \PYG{n}{H}  \PYG{l+m+mi}{16}  \PYG{n}{N}   \PYG{l+m+mf}{0.648} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{17}  \PYG{n}{H}  \PYG{l+m+mi}{17}  \PYG{n}{N}   \PYG{l+m+mf}{0.383} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{18}  \PYG{n}{H}  \PYG{l+m+mi}{18}  \PYG{n}{N}   \PYG{l+m+mf}{0.420} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{19}  \PYG{n}{H}  \PYG{l+m+mi}{19}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.863} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{21}  \PYG{n}{H}  \PYG{l+m+mi}{21}  \PYG{n}{N}   \PYG{l+m+mf}{0.973} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{22}  \PYG{n}{H}  \PYG{l+m+mi}{22}  \PYG{n}{N}   \PYG{l+m+mf}{1.026} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{23}  \PYG{n}{H}  \PYG{l+m+mi}{23}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.613} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{24}  \PYG{n}{H}  \PYG{l+m+mi}{24}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.847} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{25}  \PYG{n}{H}  \PYG{l+m+mi}{25}  \PYG{n}{N}   \PYG{l+m+mf}{1.761} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{26}  \PYG{n}{H}  \PYG{l+m+mi}{26}  \PYG{n}{N}   \PYG{l+m+mf}{6.470} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{27}  \PYG{n}{H}  \PYG{l+m+mi}{27}  \PYG{n}{N}   \PYG{l+m+mf}{5.541} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{28}  \PYG{n}{H}  \PYG{l+m+mi}{28}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.334} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{29}  \PYG{n}{H}  \PYG{l+m+mi}{29}  \PYG{n}{N}   \PYG{l+m+mf}{3.624} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{30}  \PYG{n}{H}  \PYG{l+m+mi}{30}  \PYG{n}{N}   \PYG{l+m+mf}{6.673} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{31}  \PYG{n}{H}  \PYG{l+m+mi}{31}  \PYG{n}{N}   \PYG{l+m+mf}{3.952} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{32}  \PYG{n}{H}  \PYG{l+m+mi}{32}  \PYG{n}{N}   \PYG{l+m+mf}{1.658} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{33}  \PYG{n}{H}  \PYG{l+m+mi}{33}  \PYG{n}{N}   \PYG{l+m+mf}{5.449} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{34}  \PYG{n}{H}  \PYG{l+m+mi}{34}  \PYG{n}{N}   \PYG{l+m+mf}{7.370} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{35}  \PYG{n}{H}  \PYG{l+m+mi}{35}  \PYG{n}{N}   \PYG{l+m+mf}{1.033} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{36}  \PYG{n}{H}  \PYG{l+m+mi}{36}  \PYG{n}{N}   \PYG{l+m+mf}{1.136} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{38}  \PYG{n}{H}  \PYG{l+m+mi}{38}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.378} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{39}  \PYG{n}{H}  \PYG{l+m+mi}{39}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.979} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{40}  \PYG{n}{H}  \PYG{l+m+mi}{40}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.810} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{41}  \PYG{n}{H}  \PYG{l+m+mi}{41}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.187} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{42}  \PYG{n}{H}  \PYG{l+m+mi}{42}  \PYG{n}{N}   \PYG{l+m+mf}{2.415} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{43}  \PYG{n}{H}  \PYG{l+m+mi}{43}  \PYG{n}{N}   \PYG{l+m+mf}{1.710} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{44}  \PYG{n}{H}  \PYG{l+m+mi}{44}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.977} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{45}  \PYG{n}{H}  \PYG{l+m+mi}{45}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.467} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{46}  \PYG{n}{H}  \PYG{l+m+mi}{46}  \PYG{n}{N}   \PYG{l+m+mf}{3.243} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{47}  \PYG{n}{H}  \PYG{l+m+mi}{47}  \PYG{n}{N}   \PYG{l+m+mf}{3.937} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{48}  \PYG{n}{H}  \PYG{l+m+mi}{48}  \PYG{n}{N}   \PYG{l+m+mf}{7.047} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{49}  \PYG{n}{H}  \PYG{l+m+mi}{49}  \PYG{n}{N}   \PYG{l+m+mf}{4.577} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{50}  \PYG{n}{H}  \PYG{l+m+mi}{50}  \PYG{n}{N}   \PYG{l+m+mf}{3.718} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{51}  \PYG{n}{H}  \PYG{l+m+mi}{51}  \PYG{n}{N}   \PYG{l+m+mf}{4.519} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{52}  \PYG{n}{H}  \PYG{l+m+mi}{52}  \PYG{n}{N}   \PYG{l+m+mf}{6.077} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{53}  \PYG{n}{H}  \PYG{l+m+mi}{53}  \PYG{n}{N}   \PYG{l+m+mf}{2.940} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{54}  \PYG{n}{H}  \PYG{l+m+mi}{54}  \PYG{n}{N}   \PYG{l+m+mf}{2.541} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{55}  \PYG{n}{H}  \PYG{l+m+mi}{55}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.493} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{56}  \PYG{n}{H}  \PYG{l+m+mi}{56}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.159} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{57}  \PYG{n}{H}  \PYG{l+m+mi}{57}  \PYG{n}{N}   \PYG{l+m+mf}{4.948} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{58}  \PYG{n}{H}  \PYG{l+m+mi}{58}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.078} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{59}  \PYG{n}{H}  \PYG{l+m+mi}{59}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.759} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{60}  \PYG{n}{H}  \PYG{l+m+mi}{60}  \PYG{n}{N}   \PYG{l+m+mf}{0.161} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{61}  \PYG{n}{H}  \PYG{l+m+mi}{61}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.132} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{62}  \PYG{n}{H}  \PYG{l+m+mi}{62}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.719} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{63}  \PYG{n}{H}  \PYG{l+m+mi}{63}  \PYG{n}{N}   \PYG{l+m+mf}{4.025} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{64}  \PYG{n}{H}  \PYG{l+m+mi}{64}  \PYG{n}{N}   \PYG{l+m+mf}{5.929} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{65}  \PYG{n}{H}  \PYG{l+m+mi}{65}  \PYG{n}{N}   \PYG{l+m+mf}{2.363} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{66}  \PYG{n}{H}  \PYG{l+m+mi}{66}  \PYG{n}{N}   \PYG{l+m+mf}{2.477} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{67}  \PYG{n}{H}  \PYG{l+m+mi}{67}  \PYG{n}{N}   \PYG{l+m+mf}{8.265} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{68}  \PYG{n}{H}  \PYG{l+m+mi}{68}  \PYG{n}{N}   \PYG{l+m+mf}{5.078} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{69}  \PYG{n}{H}  \PYG{l+m+mi}{69}  \PYG{n}{N}   \PYG{l+m+mf}{3.724} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{70}  \PYG{n}{H}  \PYG{l+m+mi}{70}  \PYG{n}{N}   \PYG{l+m+mf}{7.743} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{71}  \PYG{n}{H}  \PYG{l+m+mi}{71}  \PYG{n}{N}   \PYG{l+m+mf}{2.188} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{72}  \PYG{n}{H}  \PYG{l+m+mi}{72}  \PYG{n}{N}   \PYG{l+m+mf}{4.911} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{73}  \PYG{n}{H}  \PYG{l+m+mi}{73}  \PYG{n}{N}   \PYG{l+m+mf}{7.514} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{74}  \PYG{n}{H}  \PYG{l+m+mi}{74}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.001} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{75}  \PYG{n}{H}  \PYG{l+m+mi}{75}  \PYG{n}{N}   \PYG{l+m+mf}{1.119} \PYG{l+m+mf}{0.0}
\end{sphinxVerbatim}


\subsection{PRE data}
\label{\detokenize{examples/index:pre-data}}

\subsubsection{Fit Tensor to PRE Data}
\label{\detokenize{examples/pre_fit_proton:fit-tensor-to-pre-data}}\label{\detokenize{examples/pre_fit_proton:pre-fit-proton}}\label{\detokenize{examples/pre_fit_proton::doc}}
This example demonstrates fitting of the rotational correlation time \({\tau_r}\) to 1H PRE data of calbindin D9k. You can fit any parameters of the \({\chi}\)-tensor you desire, such as position or magnitude as well.


\paragraph{Downloads}
\label{\detokenize{examples/pre_fit_proton:downloads}}\begin{itemize}
\item {} 
Download the data files \sphinxcode{\sphinxupquote{4icbH\_mut.pdb}}, \sphinxcode{\sphinxupquote{calbindin\_Er\_H\_R2\_600.npc}} and \sphinxcode{\sphinxupquote{calbindin\_Tb\_H\_R2\_800.npc}} from \sphinxhref{https://github.com/henryorton/paramagpy/tree/master/examples/data\_files/}{here}:

\item {} 
Download the script \sphinxcode{\sphinxupquote{pre\_fit\_proton.py}}

\end{itemize}


\paragraph{Script + Explanation}
\label{\detokenize{examples/pre_fit_proton:script-explanation}}
Firstly, the necessary modules are imported from paramagpy.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{paramagpy} \PYG{k}{import} \PYG{n}{protein}\PYG{p}{,} \PYG{n}{fit}\PYG{p}{,} \PYG{n}{dataparse}\PYG{p}{,} \PYG{n}{metal}
\end{sphinxVerbatim}

The protein is then loaded from a PDB file.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Load the PDB file}
\PYG{n}{prot} \PYG{o}{=} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{load\PYGZus{}pdb}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/4icbH\PYGZus{}mut.pdb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

The PRE data is loaded. Note that the Er data was recorded at 600 MHz and the Tb data was recorded at 800 MHz.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{rawData\PYGZus{}er} \PYG{o}{=} \PYG{n}{dataparse}\PYG{o}{.}\PYG{n}{read\PYGZus{}pre}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/calbindin\PYGZus{}Er\PYGZus{}H\PYGZus{}R2\PYGZus{}600.pre}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{rawData\PYGZus{}tb} \PYG{o}{=} \PYG{n}{dataparse}\PYG{o}{.}\PYG{n}{read\PYGZus{}pre}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/calbindin\PYGZus{}Tb\PYGZus{}H\PYGZus{}R2\PYGZus{}800.pre}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

The \({\Delta\chi}\)-tensors that were fitted from PCS data are loaded from file and the relevant \({B_0}\) magnetic field strengths are set.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mStart\PYGZus{}er} \PYG{o}{=} \PYG{n}{metal}\PYG{o}{.}\PYG{n}{load\PYGZus{}tensor}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/calbindin\PYGZus{}Er\PYGZus{}HN\PYGZus{}PCS\PYGZus{}tensor.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{mStart\PYGZus{}tb} \PYG{o}{=} \PYG{n}{metal}\PYG{o}{.}\PYG{n}{load\PYGZus{}tensor}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/calbindin\PYGZus{}Tb\PYGZus{}HN\PYGZus{}PCS\PYGZus{}tensor.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{mStart\PYGZus{}er}\PYG{o}{.}\PYG{n}{B0} \PYG{o}{=} \PYG{l+m+mf}{14.1}
\PYG{n}{mStart\PYGZus{}tb}\PYG{o}{.}\PYG{n}{B0} \PYG{o}{=} \PYG{l+m+mf}{18.8}
\end{sphinxVerbatim}

Fitting of the rotational correlation time is done with the function {\hyperref[\detokenize{reference/generated/paramagpy.fit.nlr_fit_metal_from_pre:paramagpy.fit.nlr_fit_metal_from_pre}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.fit.nlr\_fit\_metal\_from\_pre()}}}}}. To fit position or \({\chi}\)-tensor magnitude, you can change the \sphinxcode{\sphinxupquote{params}} argument.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{m\PYGZus{}er}\PYG{p}{,}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n}{cal\PYGZus{}er}\PYG{p}{,}\PYG{p}{)}\PYG{p}{,} \PYG{n}{qfac} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{nlr\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pre}\PYG{p}{(}
	\PYG{p}{[}\PYG{n}{mStart\PYGZus{}er}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{data\PYGZus{}er}\PYG{p}{]}\PYG{p}{,} \PYG{n}{params}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{taur}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rtypes}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{(}\PYG{n}{m\PYGZus{}tb}\PYG{p}{,}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n}{cal\PYGZus{}tb}\PYG{p}{,}\PYG{p}{)}\PYG{p}{,} \PYG{n}{qfac} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{nlr\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pre}\PYG{p}{(}
	\PYG{p}{[}\PYG{n}{mStart\PYGZus{}tb}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{data\PYGZus{}tb}\PYG{p}{]}\PYG{p}{,} \PYG{n}{params}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{taur}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rtypes}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

The fitted tensors are saved to file. Note that the Er dataset gives a reasonable \({\tau_r}\) of around 4 ns which is close to the literature value of 4.25 ns. However, the Tb dataset gives an unreasonably large value of 18 ns. This is due to magnetisation attenuation due to 1H-1H RDCs present during the relaxation evolution time as discussed in \sphinxhref{https://doi.org/10.1021/jacs.8b03858}{literature} giving rise to artificially large measured PREs for lanthanides with highly anisotropic \({\Delta\chi}\)-tensors. This is also reflected in the correlation plot below.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{m\PYGZus{}er}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{calbindin\PYGZus{}Er\PYGZus{}H\PYGZus{}R2\PYGZus{}600\PYGZus{}tensor.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{m\PYGZus{}tb}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{calbindin\PYGZus{}Tb\PYGZus{}H\PYGZus{}R2\PYGZus{}800\PYGZus{}tensor.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{calbindin\_Er\_H\_R2\_600\_tensor.txt}}{]}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
ax    \textbar{} 1E\PYGZhy{}32 m\PYGZca{}3 :    \PYGZhy{}8.152
rh    \textbar{} 1E\PYGZhy{}32 m\PYGZca{}3 :    \PYGZhy{}4.911
x     \textbar{}   1E\PYGZhy{}10 m :    25.786
y     \textbar{}   1E\PYGZhy{}10 m :     9.515
z     \textbar{}   1E\PYGZhy{}10 m :     6.558
a     \textbar{}       deg :   125.841
b     \textbar{}       deg :   142.287
g     \textbar{}       deg :    41.758
mueff \textbar{}        Bm :     9.581
shift \textbar{}       ppm :     0.000
B0    \textbar{}         T :    14.100
temp  \textbar{}         K :   298.150
t1e   \textbar{}        ps :     0.189
taur  \textbar{}        ns :     3.923
\end{sphinxVerbatim}

\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{calbindin\_Tb\_H\_R2\_800\_tensor.txt}}{]}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
ax    \textbar{} 1E\PYGZhy{}32 m\PYGZca{}3 :    30.375
rh    \textbar{} 1E\PYGZhy{}32 m\PYGZca{}3 :    12.339
x     \textbar{}   1E\PYGZhy{}10 m :    25.786
y     \textbar{}   1E\PYGZhy{}10 m :     9.515
z     \textbar{}   1E\PYGZhy{}10 m :     6.558
a     \textbar{}       deg :   150.957
b     \textbar{}       deg :   152.671
g     \textbar{}       deg :    70.311
mueff \textbar{}        Bm :     9.721
shift \textbar{}       ppm :     0.000
B0    \textbar{}         T :    18.800
temp  \textbar{}         K :   298.150
t1e   \textbar{}        ps :     0.251
taur  \textbar{}        ns :    18.917
\end{sphinxVerbatim}

And the results are plotted.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{matplotlib} \PYG{k}{import} \PYG{n}{pyplot} \PYG{k}{as} \PYG{n}{plt}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Unpack the experimental values}
\PYG{n}{atm\PYGZus{}er}\PYG{p}{,} \PYG{n}{exp\PYGZus{}er}\PYG{p}{,} \PYG{n}{err\PYGZus{}er} \PYG{o}{=} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{o}{*}\PYG{n}{data\PYGZus{}er}\PYG{p}{)}
\PYG{n}{atm\PYGZus{}tb}\PYG{p}{,} \PYG{n}{exp\PYGZus{}tb}\PYG{p}{,} \PYG{n}{err\PYGZus{}tb} \PYG{o}{=} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{o}{*}\PYG{n}{data\PYGZus{}tb}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot the data}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{exp\PYGZus{}er}\PYG{p}{,} \PYG{n}{cal\PYGZus{}er}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ms}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
	\PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Er: taur = }\PYG{l+s+si}{\PYGZob{}:3.1f\PYGZcb{}}\PYG{l+s+s2}{ ns}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{l+m+mf}{1E9}\PYG{o}{*}\PYG{n}{m\PYGZus{}er}\PYG{o}{.}\PYG{n}{taur}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{exp\PYGZus{}tb}\PYG{p}{,} \PYG{n}{cal\PYGZus{}tb}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ms}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{g}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
	\PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Tb: taur = }\PYG{l+s+si}{\PYGZob{}:3.1f\PYGZcb{}}\PYG{l+s+s2}{ ns}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{l+m+mf}{1E9}\PYG{o}{*}\PYG{n}{m\PYGZus{}tb}\PYG{o}{.}\PYG{n}{taur}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot a diagonal}
\PYG{n}{l}\PYG{p}{,} \PYG{n}{h} \PYG{o}{=} \PYG{n}{ax}\PYG{o}{.}\PYG{n}{get\PYGZus{}ylim}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}k}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlim}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Make axis labels and save figure}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Experiment}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Calculated}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pre\PYGZus{}fit\PYGZus{}proton.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{pre_fit_proton}.png}


\subsubsection{Calculate 15N PREs with cross-correlation effects}
\label{\detokenize{examples/pre_calc_nitrogen:calculate-15n-pres-with-cross-correlation-effects}}\label{\detokenize{examples/pre_calc_nitrogen:pre-calc-nitrogen}}\label{\detokenize{examples/pre_calc_nitrogen::doc}}
This example shows how to conduct a weighted fit of a \({\Delta\chi}\)-tensor to experimental PCS data with experimental errors.


\paragraph{Downloads}
\label{\detokenize{examples/pre_calc_nitrogen:downloads}}\begin{itemize}
\item {} 
Download the data files \sphinxcode{\sphinxupquote{4icbH\_mut.pdb}}, \sphinxcode{\sphinxupquote{calbindin\_Tb\_N\_R1\_600.pre}} and \sphinxcode{\sphinxupquote{calbindin\_Tb\_HN\_PCS\_tensor.txt}} from \sphinxhref{https://github.com/henryorton/paramagpy/tree/master/examples/data\_files/}{here}:

\item {} 
Download the script \sphinxcode{\sphinxupquote{pre\_calc\_nitrogen.py}}

\end{itemize}


\paragraph{Script + Explanation}
\label{\detokenize{examples/pre_calc_nitrogen:script-explanation}}
First the relevant modules are loaded, the protein and data are read and the data is parsed by the protein.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{paramagpy} \PYG{k}{import} \PYG{n}{protein}\PYG{p}{,} \PYG{n}{metal}\PYG{p}{,} \PYG{n}{dataparse}

\PYG{c+c1}{\PYGZsh{} Load the PDB file}
\PYG{n}{prot} \PYG{o}{=} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{load\PYGZus{}pdb}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/4icbH\PYGZus{}mut.pdb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Load PRE data}
\PYG{n}{rawData} \PYG{o}{=} \PYG{n}{dataparse}\PYG{o}{.}\PYG{n}{read\PYGZus{}pre}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/calbindin\PYGZus{}Tb\PYGZus{}N\PYGZus{}R1\PYGZus{}600.pre}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Parse PRE data}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{prot}\PYG{o}{.}\PYG{n}{parse}\PYG{p}{(}\PYG{n}{rawData}\PYG{p}{)}
\end{sphinxVerbatim}

The Tb tensor fitted from PCS data is loaded and the relevant parameters, in this case the magnetic field strength, temperature and rotational correlation time are set.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{met} \PYG{o}{=} \PYG{n}{metal}\PYG{o}{.}\PYG{n}{load\PYGZus{}tensor}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/calbindin\PYGZus{}Tb\PYGZus{}HN\PYGZus{}PCS\PYGZus{}tensor.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{met}\PYG{o}{.}\PYG{n}{B0} \PYG{o}{=} \PYG{l+m+mf}{14.1}
\PYG{n}{met}\PYG{o}{.}\PYG{n}{T} \PYG{o}{=} \PYG{l+m+mf}{298.0}
\PYG{n}{met}\PYG{o}{.}\PYG{n}{taur} \PYG{o}{=} \PYG{l+m+mf}{4.25E\PYGZhy{}9}
\end{sphinxVerbatim}

A loop is conducted over the nitrogen atoms that are present in the experimental data. The PRE is calculated using the function \sphinxcode{\sphinxupquote{paramagpy.metal.atom\_pre()}}. Calculations without CSA are appended to the list \sphinxcode{\sphinxupquote{cal}} and calculations including CSA cross-correlation with the Curie-spin relaxation are appended to the list \sphinxcode{\sphinxupquote{cal\_csa}}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{exp} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{cal} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{cal\PYGZus{}csa} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{atom}\PYG{p}{,} \PYG{n}{pre}\PYG{p}{,} \PYG{n}{err} \PYG{o+ow}{in} \PYG{n}{data}\PYG{p}{:}
	\PYG{n}{exp}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{pre}\PYG{p}{)}
	\PYG{n}{cal}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{met}\PYG{o}{.}\PYG{n}{atom\PYGZus{}pre}\PYG{p}{(}\PYG{n}{atom}\PYG{p}{,} \PYG{n}{rtype}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
	\PYG{n}{cal\PYGZus{}csa}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{met}\PYG{o}{.}\PYG{n}{atom\PYGZus{}pre}\PYG{p}{(}\PYG{n}{atom}\PYG{p}{,} \PYG{n}{rtype}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{csa}\PYG{o}{=}\PYG{n}{atom}\PYG{o}{.}\PYG{n}{csa}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

Finally the data are plotted. Clearly CSA cross-correlation is a big effect for backbone nitrogen atoms and should always be taken into account for Curie-spin calculations. Also note the existence and correct prediction of negative PREs!

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{matplotlib} \PYG{k}{import} \PYG{n}{pyplot} \PYG{k}{as} \PYG{n}{plt}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot the data}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{exp}\PYG{p}{,} \PYG{n}{cal}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Standard Theory}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{exp}\PYG{p}{,} \PYG{n}{cal\PYGZus{}csa}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CSA x Curie spin}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot a diagonal}
\PYG{n}{l}\PYG{p}{,} \PYG{n}{h} \PYG{o}{=} \PYG{n}{ax}\PYG{o}{.}\PYG{n}{get\PYGZus{}xlim}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{grey}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlim}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Make axis labels and save figure}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Experiment}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Calculated}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pre\PYGZus{}calc\PYGZus{}nitrogen.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{pre\_calc\_nitrogen.png}}{]}

\noindent\sphinxincludegraphics{{pre_calc_nitrogen}.png}


\subsection{CCR data}
\label{\detokenize{examples/index:ccr-data}}

\subsubsection{Calculate Cross-correlated Relaxation}
\label{\detokenize{examples/ccr_calculate:calculate-cross-correlated-relaxation}}\label{\detokenize{examples/ccr_calculate:ccr-calculate}}\label{\detokenize{examples/ccr_calculate::doc}}
This example shows how to calculate dipole-dipole/Curie-spin cross-correlated relaxation as measured for data in the literature by \sphinxhref{https://doi.org/10.1023/A:1024926126239}{Pintacuda et. al.}


\paragraph{Downloads}
\label{\detokenize{examples/ccr_calculate:downloads}}\begin{itemize}
\item {} 
Download the data files \sphinxcode{\sphinxupquote{1bzrH.pdb}}, \sphinxcode{\sphinxupquote{myoglobin\_cn.ccr}} and \sphinxcode{\sphinxupquote{myoglobin\_f.ccr}} from \sphinxhref{https://github.com/henryorton/paramagpy/tree/master/examples/data\_files/}{here}:

\item {} 
Download the script \sphinxcode{\sphinxupquote{ccr\_calculate.py}}

\end{itemize}


\paragraph{Script + Explanation}
\label{\detokenize{examples/ccr_calculate:script-explanation}}
First the relevant modules are loaded, and the iron atom (paramagnetic centre) is identified as the variable \sphinxcode{\sphinxupquote{ironAtom}}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{paramagpy} \PYG{k}{import} \PYG{n}{protein}\PYG{p}{,} \PYG{n}{fit}\PYG{p}{,} \PYG{n}{dataparse}\PYG{p}{,} \PYG{n}{metal}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{c+c1}{\PYGZsh{} Load the PDB file and get iron centre}
\PYG{n}{prot} \PYG{o}{=} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{load\PYGZus{}pdb}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/1bzrH.pdb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ironAtom} \PYG{o}{=} \PYG{n}{prot}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H\PYGZus{}HEM}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{154}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{FE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\end{sphinxVerbatim}

Two paramagnetic centres are defined for the high and low spin iron atom. The positions are set to that of the iron centre along with other relevant parameters. The measured isotropic \({\chi}\)-tensor magnitudes are also set.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{met\PYGZus{}cn} \PYG{o}{=} \PYG{n}{metal}\PYG{o}{.}\PYG{n}{Metal}\PYG{p}{(}\PYG{n}{position}\PYG{o}{=}\PYG{n}{ironAtom}\PYG{o}{.}\PYG{n}{position}\PYG{p}{,} 
					 \PYG{n}{B0}\PYG{o}{=}\PYG{l+m+mf}{18.79}\PYG{p}{,} 
					 \PYG{n}{temperature}\PYG{o}{=}\PYG{l+m+mf}{303.0}\PYG{p}{,}
					 \PYG{n}{taur}\PYG{o}{=}\PYG{l+m+mf}{5.7E\PYGZhy{}9}\PYG{p}{)}
\PYG{n}{met\PYGZus{}f} \PYG{o}{=} \PYG{n}{met\PYGZus{}cn}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{met\PYGZus{}cn}\PYG{o}{.}\PYG{n}{iso} \PYG{o}{=} \PYG{l+m+mf}{4.4E\PYGZhy{}32}
\PYG{n}{met\PYGZus{}f}\PYG{o}{.}\PYG{n}{iso} \PYG{o}{=} \PYG{l+m+mf}{30.1E\PYGZhy{}32}
\end{sphinxVerbatim}

The experimental data are loaded and parsed by the protein.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{data\PYGZus{}cn} \PYG{o}{=} \PYG{n}{prot}\PYG{o}{.}\PYG{n}{parse}\PYG{p}{(}\PYG{n}{dataparse}\PYG{o}{.}\PYG{n}{read\PYGZus{}ccr}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{../data\PYGZus{}files/myoglobin\PYGZus{}cn.ccr}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{data\PYGZus{}f} \PYG{o}{=} \PYG{n}{prot}\PYG{o}{.}\PYG{n}{parse}\PYG{p}{(}\PYG{n}{dataparse}\PYG{o}{.}\PYG{n}{read\PYGZus{}ccr}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{../data\PYGZus{}files/myoglobin\PYGZus{}f.ccr}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

A loop is conducted over the atoms contained in the experimental data and the CCR rate is calculated using the function {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.atom_ccr:paramagpy.metal.Metal.atom_ccr}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.atom\_ccr()}}}}}. These are appended to lists \sphinxcode{\sphinxupquote{compare\_cn}} and \sphinxcode{\sphinxupquote{compare\_f}}.

Note that the two H and N atoms are provided. The first atom is the nuclear spin undergoing active relaxation. The second atom is the coupling partner. Thus by swapping the H and N atoms to give \sphinxcode{\sphinxupquote{atom\_ccr(N, H)}}, the differential line broadening can be calculated in the indirect dimension.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Calculate the cross\PYGZhy{}correlated realxation}
\PYG{n}{compare\PYGZus{}cn} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{H}\PYG{p}{,} \PYG{n}{N}\PYG{p}{,} \PYG{n}{value}\PYG{p}{,} \PYG{n}{error} \PYG{o+ow}{in} \PYG{n}{data\PYGZus{}cn}\PYG{p}{:}
	\PYG{n}{delta} \PYG{o}{=} \PYG{n}{met\PYGZus{}cn}\PYG{o}{.}\PYG{n}{atom\PYGZus{}ccr}\PYG{p}{(}\PYG{n}{H}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}
	\PYG{n}{compare\PYGZus{}cn}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{(}\PYG{n}{value}\PYG{p}{,} \PYG{n}{delta}\PYG{o}{*}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{compare\PYGZus{}f} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{H}\PYG{p}{,} \PYG{n}{N}\PYG{p}{,} \PYG{n}{value}\PYG{p}{,} \PYG{n}{error} \PYG{o+ow}{in} \PYG{n}{data\PYGZus{}f}\PYG{p}{:}
	\PYG{n}{delta} \PYG{o}{=} \PYG{n}{met\PYGZus{}f}\PYG{o}{.}\PYG{n}{atom\PYGZus{}ccr}\PYG{p}{(}\PYG{n}{H}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}
	\PYG{n}{compare\PYGZus{}f}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{(}\PYG{n}{value}\PYG{p}{,} \PYG{n}{delta}\PYG{o}{*}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

Finally a correlation plot is made.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{} Plot the correlation \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{k+kn}{from} \PYG{n+nn}{matplotlib} \PYG{k}{import} \PYG{n}{pyplot} \PYG{k}{as} \PYG{n}{plt}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot the data correlations}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{o}{*}\PYG{n+nb}{zip}\PYG{p}{(}\PYG{o}{*}\PYG{n}{compare\PYGZus{}cn}\PYG{p}{)}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{myo\PYGZus{}cn}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{o}{*}\PYG{n+nb}{zip}\PYG{p}{(}\PYG{o}{*}\PYG{n}{compare\PYGZus{}f}\PYG{p}{)}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{myo\PYGZus{}f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot a diagonal}
\PYG{n}{l}\PYG{p}{,} \PYG{n}{h} \PYG{o}{=} \PYG{n}{ax}\PYG{o}{.}\PYG{n}{get\PYGZus{}xlim}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}k}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlim}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Make axis labels and save figure}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Experiment}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Calculated}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ccr\PYGZus{}calculate.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{ccr\_calculate.png}}{]}

\noindent\sphinxincludegraphics{{ccr_calculate}.png}


\section{Graphic User Interface (GUI)}
\label{\detokenize{paramagpy_gui:graphic-user-interface-gui}}\label{\detokenize{paramagpy_gui:paramagpy-gui}}\label{\detokenize{paramagpy_gui::doc}}
Paramagpy is equipped with a GUI which is cross-platform and contains most of the functionality of the scripted module. This gives a rapid way for new users to fit and compare PCS, RDC and PRE effects.


\subsection{YouTube Tutorial}
\label{\detokenize{paramagpy_gui:youtube-tutorial}}
\sphinxhref{https://youtu.be/MAoBItSac-g}{Check out the tutorial on YouTube}




\subsection{Running the GUI}
\label{\detokenize{paramagpy_gui:running-the-gui}}
To run the GUI, first open the python inperpreter in the terminal

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
user@computer:\PYGZti{}\PYGZdl{} python3
Python \PYG{l+m}{3}.5.2 \PYG{o}{(}default, Nov \PYG{l+m}{23} \PYG{l+m}{2017}, \PYG{l+m}{16}:37:01\PYG{o}{)}
\PYG{o}{[}GCC \PYG{l+m}{5}.4.0 \PYG{l+m}{20160609}\PYG{o}{]} on linux
Type \PYG{l+s+s2}{\PYGZdq{}help\PYGZdq{}}, \PYG{l+s+s2}{\PYGZdq{}copyright\PYGZdq{}}, \PYG{l+s+s2}{\PYGZdq{}credits\PYGZdq{}} or \PYG{l+s+s2}{\PYGZdq{}license\PYGZdq{}} \PYG{k}{for} more information.
\PYGZgt{}\PYGZgt{}\PYGZgt{}
\end{sphinxVerbatim}

Then import paramagpy and start the gui with \sphinxcode{\sphinxupquote{paramagpy.gui.run()}}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
user@computer:\PYGZti{}\PYGZdl{} python3
Python \PYG{l+m}{3}.5.2 \PYG{o}{(}default, Nov \PYG{l+m}{23} \PYG{l+m}{2017}, \PYG{l+m}{16}:37:01\PYG{o}{)}
\PYG{o}{[}GCC \PYG{l+m}{5}.4.0 \PYG{l+m}{20160609}\PYG{o}{]} on linux
Type \PYG{l+s+s2}{\PYGZdq{}help\PYGZdq{}}, \PYG{l+s+s2}{\PYGZdq{}copyright\PYGZdq{}}, \PYG{l+s+s2}{\PYGZdq{}credits\PYGZdq{}} or \PYG{l+s+s2}{\PYGZdq{}license\PYGZdq{}} \PYG{k}{for} more information.
\PYGZgt{}\PYGZgt{}\PYGZgt{} import paramagpy
\PYGZgt{}\PYGZgt{}\PYGZgt{} paramagpy.gui.run\PYG{o}{(}\PYG{o}{)}
\end{sphinxVerbatim}

Alternatively you can simply execute the following from the command line

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
user@computer:\PYGZti{}\PYGZdl{} \PYG{n+nb}{echo} \PYG{l+s+s2}{\PYGZdq{}import paramagpy; paramagpy.gui.run()\PYGZdq{}} \PYG{p}{\textbar{}} python3
\end{sphinxVerbatim}

If all this fails, you can contact the author for a prebuilt executable at \sphinxhref{mailto:henry.orton@anu.edu.au}{henry.orton@anu.edu.au}

\noindent\sphinxincludegraphics{{paramagpy_gui_annot}.png}


\section{NMR Software Macros}
\label{\detokenize{nmr_software_macros/index:nmr-software-macros}}\label{\detokenize{nmr_software_macros/index:nmr-software-macros-index}}\label{\detokenize{nmr_software_macros/index::doc}}
Paramagpy includes scripts for reading/writing PCS values directly from popular NMR software. This drastically improves the iterative process of tensor fitting.


\subsection{CCPNMR Analysis 2.4}
\label{\detokenize{nmr_software_macros/index:ccpnmr-analysis-2-4}}
Download the two scripts:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{paramagpy\_ccpnmr\_macro.py}}

\item {} 
\sphinxcode{\sphinxupquote{paramagpy\_fit\_pcs.py}}

\end{itemize}

In the first line of the script \sphinxtitleref{paramagpy\_fit\_pcs.py}, replace the shebang with the path to the python version on your machine that contains the paramagpy installation. On my computer this is set to.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/usr/bin/python3}
\end{sphinxVerbatim}

Open CCPNMR analysis and navigate to Menu-\textgreater{}Macro-\textgreater{}Organise Macros. At the lower right click \sphinxtitleref{Add Macro} and open the script \sphinxtitleref{paramagpy\_ccpnmr\_macro.py}, then select \sphinxtitleref{paramagpyMACRO} and click \sphinxtitleref{Load Macro}. You can then select if from the list and click \sphinxtitleref{Run} to reveal the screen below.

\noindent\sphinxincludegraphics{{ccpnmr_screen}.png}

The popup window allows you to select a diamagnetic and paramagnetic spectrum and has 3 available buttons:
\begin{itemize}
\item {} 
Write PCS: This will calculate the difference between assigned peaks in the paramagnetic and diamagnetic spectra and write them to a .npc file (as specified in the relevant field).

\item {} 
Fit Tensor: This will call the paramagpy script \sphinxtitleref{paramagpy\_fit\_pcs.py} to fit the tensor the the written PCS values.

\item {} 
Read PCS: This will read back-calculated PCS values from file (as specified in the relevant field) and plot the expected peaks on the paramagnetic spectrum in red.

\end{itemize}

Note, to alter the parameters for fitting of the PCS tensor, you can change the values within the script \sphinxtitleref{paramagpy\_fit\_pcs.py}.


\subsection{Sparky}
\label{\detokenize{nmr_software_macros/index:sparky}}
Download the 3 scripts:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{paramagpy\_sparky\_macro.py}}

\item {} 
\sphinxcode{\sphinxupquote{sparky\_init.py}}

\item {} 
\sphinxcode{\sphinxupquote{paramagpy\_fit\_pcs.py}}

\end{itemize}

Place the first two scripts \sphinxtitleref{paramagpy\_sparky\_macro.py} and \sphinxtitleref{sparky\_init.py} in the Sparky directory \sphinxtitleref{\textasciitilde{}/Sparky/Python}. Note that the Sparky directory usually contains the \sphinxtitleref{Projects}, \sphinxtitleref{Lists} and \sphinxtitleref{Save} folders. You may need to create the \sphinxtitleref{Python} directory here in which to place the two scripts.

Place the third script \sphinxtitleref{paramagpy\_fit\_pcs.py} in your home directory.

Open Sparky and navigate to Extensions-\textgreater{}Read and write PCS files.

\noindent\sphinxincludegraphics{{sparky_screen}.png}

The popup window allows you to select a diamagnetic and paramagnetic spectrum and has 3 available buttons:
\begin{itemize}
\item {} 
Write PCS: This will calculate the difference between assigned peaks in the paramagnetic and diamagnetic spectra and write them to a .npc file (as specified in the relevant field).

\item {} 
Read PCS: This will read back-calculated PCS values from file (as specified in the relevant field) and plot the expected peaks on the paramagnetic spectrum in green.

\item {} 
Clear PCS: This will remove all calculated PCS peaks from the spectrum.

\end{itemize}

Note, to perform the tensor fitting, you will need to execute the paramagpy script in a separate terminal including an argument with the experimental PCS file such as:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
user@computer:\PYGZti{}\PYGZdl{} ./paramagpy\PYGZus{}fit\PYGZus{}pcs.py pcsexp.npc
\end{sphinxVerbatim}

To alter the parameters for fitting of the PCS tensor, you can change the values within the script \sphinxtitleref{paramagpy\_fit\_pcs.py}.


\section{Reference Guide}
\label{\detokenize{reference/index:reference-guide}}\label{\detokenize{reference/index:reference-index}}\label{\detokenize{reference/index::doc}}

\subsection{Paramagnetic module}
\label{\detokenize{reference/index:paramagnetic-module}}
This module handles the paramagnetic centre by defining the magnetic susceptibility
tensor and methods for PCS, RDC and PRE calculations.


\subsubsection{paramagpy.metal}
\label{\detokenize{reference/metal:module-paramagpy.metal}}\label{\detokenize{reference/metal:paramagpy-metal}}\label{\detokenize{reference/metal:metal}}\label{\detokenize{reference/metal::doc}}\index{paramagpy.metal (module)}

\paragraph{Functions}
\label{\detokenize{reference/metal:functions}}

\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{reference/generated/paramagpy.metal.euler_to_matrix:paramagpy.metal.euler_to_matrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{euler\_to\_matrix}}}}}(eulers)
&
Calculate a rotation matrix from euler angles using ZYZ convention
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.matrix_to_euler:paramagpy.metal.matrix_to_euler}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{matrix\_to\_euler}}}}}(M)
&
Calculate Euler angles from a rotation matrix using ZYZ convention
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.unique_eulers:paramagpy.metal.unique_eulers}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{unique\_eulers}}}}}(eulers)
&
Calculate Euler angles in unique tensor representation.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.make_tensor:paramagpy.metal.make_tensor}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{make\_tensor}}}}}(x, y, z, axial, rhombic, alpha, …)
&
Make a ChiTensor isntance from given parameters.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{paramagpy.metal.euler\_to\_matrix}
\label{\detokenize{reference/generated/paramagpy.metal.euler_to_matrix:paramagpy-metal-euler-to-matrix}}\label{\detokenize{reference/generated/paramagpy.metal.euler_to_matrix::doc}}\index{euler\_to\_matrix() (in module paramagpy.metal)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.euler_to_matrix:paramagpy.metal.euler_to_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.metal.}}\sphinxbfcode{\sphinxupquote{euler\_to\_matrix}}}{\emph{eulers}}{}
Calculate a rotation matrix from euler angles using ZYZ convention
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{eulers}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}) \textendash{} the euler angles {[}alpha,beta,gamma{]} in radians
by ZYZ convention.

\item[{Returns}] \leavevmode
\sphinxstylestrong{matrix} \textendash{} the rotation matrix

\item[{Return type}] \leavevmode
3x3 numpy ndarray

\end{description}\end{quote}
\subsubsection*{Examples}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{eulers} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mf}{1.2}\PYG{p}{,}\PYG{l+m+mf}{0.8}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{euler\PYGZus{}to\PYGZus{}matrix}\PYG{p}{(}\PYG{n}{eulers}\PYG{p}{)}
\PYG{g+go}{array([[\PYGZhy{}0.1223669 , \PYGZhy{}0.5621374 ,  0.81794125],}
\PYG{g+go}{       [ 0.75057357,  0.486796  ,  0.44684334],}
\PYG{g+go}{       [\PYGZhy{}0.64935788,  0.66860392,  0.36235775]])}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{paramagpy.metal.matrix\_to\_euler}
\label{\detokenize{reference/generated/paramagpy.metal.matrix_to_euler:paramagpy-metal-matrix-to-euler}}\label{\detokenize{reference/generated/paramagpy.metal.matrix_to_euler::doc}}\index{matrix\_to\_euler() (in module paramagpy.metal)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.matrix_to_euler:paramagpy.metal.matrix_to_euler}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.metal.}}\sphinxbfcode{\sphinxupquote{matrix\_to\_euler}}}{\emph{M}}{}
Calculate Euler angles from a rotation matrix using ZYZ convention
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{M}} (\sphinxstyleliteralemphasis{\sphinxupquote{3x3 numpy ndarray}}) \textendash{} a rotation matrix

\item[{Returns}] \leavevmode
\sphinxstylestrong{eulers} \textendash{} the euler angles {[}alpha,beta,gamma{]} in radians
by ZYZ convention

\item[{Return type}] \leavevmode
array of floats

\end{description}\end{quote}
\subsubsection*{Examples}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{matrix} \PYG{o}{=} \PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.1223669} \PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5621374} \PYG{p}{,}  \PYG{l+m+mf}{0.81794125}\PYG{p}{]}\PYG{p}{,}
\PYG{g+go}{                    [ 0.75057357,  0.486796  ,  0.44684334],}
\PYG{g+go}{                    [\PYGZhy{}0.64935788,  0.66860392,  0.36235775]])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{matrix\PYGZus{}to\PYGZus{}euler}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{)}
\PYG{g+go}{np.array([0.5,1.2,0.8])}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{paramagpy.metal.unique\_eulers}
\label{\detokenize{reference/generated/paramagpy.metal.unique_eulers:paramagpy-metal-unique-eulers}}\label{\detokenize{reference/generated/paramagpy.metal.unique_eulers::doc}}\index{unique\_eulers() (in module paramagpy.metal)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.unique_eulers:paramagpy.metal.unique_eulers}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.metal.}}\sphinxbfcode{\sphinxupquote{unique\_eulers}}}{\emph{eulers}}{}
Calculate Euler angles in unique tensor representation.

Given general Euler angles by ZYZ convention, this function accounts for
the symmetry of a second rank symmetric tensor to map all angles within
the range {[}0, pi{]}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{eulers}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of float}}) \textendash{} the three Euler angles in radians

\item[{Returns}] \leavevmode
\sphinxstylestrong{eulers\_utr} \textendash{} the euler angles {[}alpha,beta,gamma{]} in radians
by ZYZ convention

\item[{Return type}] \leavevmode
array of floats

\end{description}\end{quote}
\subsubsection*{Examples}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{eulers} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.2}\PYG{p}{,}\PYG{l+m+mf}{10.3}\PYG{p}{,}\PYG{l+m+mf}{0.1}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{unique\PYGZus{}eulers}\PYG{p}{(}\PYG{n}{eulers}\PYG{p}{)}
\PYG{g+go}{np.array([1.08318531 0.87522204 3.04159265])}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{paramagpy.metal.make\_tensor}
\label{\detokenize{reference/generated/paramagpy.metal.make_tensor:paramagpy-metal-make-tensor}}\label{\detokenize{reference/generated/paramagpy.metal.make_tensor::doc}}\index{make\_tensor() (in module paramagpy.metal)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.make_tensor:paramagpy.metal.make_tensor}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.metal.}}\sphinxbfcode{\sphinxupquote{make\_tensor}}}{\emph{x}, \emph{y}, \emph{z}, \emph{axial}, \emph{rhombic}, \emph{alpha}, \emph{beta}, \emph{gamma}, \emph{lanthanide=None}, \emph{temperature=298.15}}{}
Make a ChiTensor isntance from given parameters.
This is designed to use pdb coordinates (x, y, z) and euler angles
from an output like Numbat.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y}}\sphinxstyleliteralstrong{\sphinxupquote{, }}\sphinxstyleliteralstrong{\sphinxupquote{z}} (\sphinxstyleliteralemphasis{\sphinxupquote{x}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}) \textendash{} tensor position in pdb coordiante in Angstroms

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rhombic}} (\sphinxstyleliteralemphasis{\sphinxupquote{axial}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}) \textendash{} the tensor anisotropies in units 10\textasciicircum{}-32

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{beta}}\sphinxstyleliteralstrong{\sphinxupquote{, }}\sphinxstyleliteralstrong{\sphinxupquote{gamma}} (\sphinxstyleliteralemphasis{\sphinxupquote{alpha}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}) \textendash{} the euler angles in degrees that maps the tensor
to the pdb (I think?)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{ChiTensor} \textendash{} a tensor object for calulating paramagnetic effects on
nuclear spins in the pdb coordinate

\item[{Return type}] \leavevmode
object {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal:paramagpy.metal.Metal}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal}}}}}

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{Classes}
\label{\detokenize{reference/metal:classes}}

\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal:paramagpy.metal.Metal}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Metal}}}}}({[}position, eulers, axrh, mueff, …{]})
&
An object for paramagnetic chi tensors and delta-chi tensors.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{paramagpy.metal.Metal}
\label{\detokenize{reference/generated/paramagpy.metal.Metal:paramagpy-metal-metal}}\label{\detokenize{reference/generated/paramagpy.metal.Metal::doc}}\index{Metal (class in paramagpy.metal)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal:paramagpy.metal.Metal}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{paramagpy.metal.}}\sphinxbfcode{\sphinxupquote{Metal}}}{\emph{position=(0}, \emph{0}, \emph{0)}, \emph{eulers=(0}, \emph{0}, \emph{0)}, \emph{axrh=(0}, \emph{0)}, \emph{mueff=0.0}, \emph{shift=0.0}, \emph{temperature=298.15}, \emph{t1e=0.0}, \emph{B0=18.79}, \emph{taur=0.0}}{}
An object for paramagnetic chi tensors and delta-chi tensors.
This class has basic attributes that specify position,
axiality/rhombicity, isotropy and euler angles.
It also has methods for calculating PCS, RDC, PRE and CCR values.
\index{\_\_init\_\_() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal:paramagpy.metal.Metal.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{position=(0}, \emph{0}, \emph{0)}, \emph{eulers=(0}, \emph{0}, \emph{0)}, \emph{axrh=(0}, \emph{0)}, \emph{mueff=0.0}, \emph{shift=0.0}, \emph{temperature=298.15}, \emph{t1e=0.0}, \emph{B0=18.79}, \emph{taur=0.0}}{}
Instantiate ChiTensor object
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{position}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} the (x,y,z) position in meters. Default is (0,0,0)
stored as a np.matrix object.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{eulers}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} the euler angles {[}alpha,beta,gamma{]} in radians
by ZYZ convention. Defualt is (0,0,0)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{axrh}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} the axial and rhombic values defining the magnetic susceptibility
anisotropy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mueff}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} the effective magnetic moment in units of A.m\textasciicircum{}2

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{shift}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} a bulk shift value applied to all PCS calculations.
This is a correction parameter that may arise due to an offset
between diamagnetic and paramagnetic PCS datasets.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{temperature}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} the temperature in Kelvin

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{t1e}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} the longitudinal electronic relaxation time

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{B0}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} the magnetic field in Telsa

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{taur}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} the rotational correlation time in seconds

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.atom_ccr:paramagpy.metal.Metal.atom_ccr}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{atom\_ccr}}}}}(atom, atomPartner)
&
Calculate R2 cross-corelated relaxation due to DDxDSA
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.atom_pcs:paramagpy.metal.Metal.atom_pcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{atom\_pcs}}}}}(atom{[}, racs, rads{]})
&
Calculate the psuedo-contact shift at the given atom
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.atom_pre:paramagpy.metal.Metal.atom_pre}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{atom\_pre}}}}}(atom{[}, rtype, dsa, sbm, csa{]})
&
Calculate the PRE for an atom
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.atom_rdc:paramagpy.metal.Metal.atom_rdc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{atom\_rdc}}}}}(atom1, atom2)
&
Calculate the residual dipolar coupling between two atoms
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.atom_set_position:paramagpy.metal.Metal.atom_set_position}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{atom\_set\_position}}}}}(atom)
&
Set the position of the Metal object to that of an atom
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.ccr:paramagpy.metal.Metal.ccr}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ccr}}}}}(position, gamma, dipole\_shift\_tensor)
&
Calculate R2 cross-corelated relaxation due to DDxDSA
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.copy:paramagpy.metal.Metal.copy}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{copy}}}}}()
&
Copy the current Metal object to a new instance
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.dipole_shift_tensor:paramagpy.metal.Metal.dipole_shift_tensor}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dipole\_shift\_tensor}}}}}(position)
&
Calculate the chemical shift tensor at the given postition
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.dsa_r1:paramagpy.metal.Metal.dsa_r1}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dsa\_r1}}}}}(position, gamma{[}, csa{]})
&
Calculate R1 relaxation due to Curie Spin
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.dsa_r2:paramagpy.metal.Metal.dsa_r2}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dsa\_r2}}}}}(position, gamma{[}, csa{]})
&
Calculate R2 relaxation due to Curie Spin
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.fast_ccr:paramagpy.metal.Metal.fast_ccr}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fast\_ccr}}}}}(posarray, gammaarray, dstarray)
&
Vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.ccr:paramagpy.metal.Metal.ccr}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.ccr()}}}}}
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.fast_dipole_shift_tensor:paramagpy.metal.Metal.fast_dipole_shift_tensor}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fast\_dipole\_shift\_tensor}}}}}(posarray)
&
A vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.dipole_shift_tensor:paramagpy.metal.Metal.dipole_shift_tensor}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.dipole\_shift\_tensor()}}}}}
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.fast_dsa_r1:paramagpy.metal.Metal.fast_dsa_r1}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fast\_dsa\_r1}}}}}(posarray, gammaarray{[}, csaarray{]})
&
Vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.dsa_r1:paramagpy.metal.Metal.dsa_r1}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.dsa\_r1()}}}}}
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.fast_dsa_r2:paramagpy.metal.Metal.fast_dsa_r2}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fast\_dsa\_r2}}}}}(posarray, gammaarray{[}, csaarray{]})
&
Vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.dsa_r2:paramagpy.metal.Metal.dsa_r2}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.dsa\_r2()}}}}}
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.fast_first_invariant_squared:paramagpy.metal.Metal.fast_first_invariant_squared}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fast\_first\_invariant\_squared}}}}}(t)
&
Vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.first_invariant_squared:paramagpy.metal.Metal.first_invariant_squared}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.first\_invariant\_squared()}}}}}
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.fast_pcs:paramagpy.metal.Metal.fast_pcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fast\_pcs}}}}}(posarray)
&
A vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.pcs:paramagpy.metal.Metal.pcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.pcs()}}}}}
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.fast_pre:paramagpy.metal.Metal.fast_pre}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fast\_pre}}}}}(posarray, gammaarray, rtype{[}, dsa, …{]})
&
Calculate the PRE for a set of spins using Curie and or SBM theory
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.fast_racs:paramagpy.metal.Metal.fast_racs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fast\_racs}}}}}(csaarray)
&
A vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.racs:paramagpy.metal.Metal.racs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.racs()}}}}}
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.fast_rads:paramagpy.metal.Metal.fast_rads}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fast\_rads}}}}}(posarray)
&
A vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.rads:paramagpy.metal.Metal.rads}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.rads()}}}}}
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.fast_rdc:paramagpy.metal.Metal.fast_rdc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fast\_rdc}}}}}(vecarray, gammaProdArray)
&
A vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.rdc:paramagpy.metal.Metal.rdc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.rdc()}}}}} method.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.fast_sbm_r1:paramagpy.metal.Metal.fast_sbm_r1}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fast\_sbm\_r1}}}}}(posarray, gammaarray)
&
Vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.sbm_r1:paramagpy.metal.Metal.sbm_r1}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.sbm\_r1()}}}}}
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.fast_sbm_r2:paramagpy.metal.Metal.fast_sbm_r2}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fast\_sbm\_r2}}}}}(posarray, gammaarray)
&
Vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.sbm_r2:paramagpy.metal.Metal.sbm_r2}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.sbm\_r2()}}}}}
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.fast_second_invariant_squared:paramagpy.metal.Metal.fast_second_invariant_squared}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fast\_second\_invariant\_squared}}}}}(t)
&
Vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.second_invariant_squared:paramagpy.metal.Metal.second_invariant_squared}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.second\_invariant\_squared()}}}}}
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.first_invariant_squared:paramagpy.metal.Metal.first_invariant_squared}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{first\_invariant\_squared}}}}}(t)
&
Calculate the antisymmetric contribution to relaxation via the first invariant of a tensor.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.get_params:paramagpy.metal.Metal.get_params}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_params}}}}}(params)
&
Get tensor parameters that have been scaled appropriately
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.info:paramagpy.metal.Metal.info}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{info}}}}}({[}comment{]})
&
Get basic information about the Metal object
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.isomap:paramagpy.metal.Metal.isomap}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{isomap}}}}}({[}protein, isoval{]})
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.make_mesh:paramagpy.metal.Metal.make_mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{make\_mesh}}}}}({[}density, size{]})
&
Construct a 3D grid of points to map an isosurface
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.pcs:paramagpy.metal.Metal.pcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pcs}}}}}(position)
&
Calculate the psuedo-contact shift at the given postition
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.pcs_mesh:paramagpy.metal.Metal.pcs_mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pcs\_mesh}}}}}(mesh)
&
Calculate a PCS value at each location of cubic grid of points
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.pre:paramagpy.metal.Metal.pre}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pre}}}}}(position, gamma, rtype{[}, dsa, sbm, csa{]})
&
Calculate the PRE for a set of spins using Curie and or SBM theory
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.pre_mesh:paramagpy.metal.Metal.pre_mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pre\_mesh}}}}}(mesh{[}, gamma, rtype, dsa, sbm{]})
&
Calculate a PRE value at each location of cubic grid of points
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.racs:paramagpy.metal.Metal.racs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{racs}}}}}(csa)
&
Calculate the residual anisotropic chemical shift at the given postition.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.rads:paramagpy.metal.Metal.rads}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{rads}}}}}(position)
&
Calculate the residual anisotropic dipolar shift at the given postition.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.rdc:paramagpy.metal.Metal.rdc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{rdc}}}}}(vector, gammaProd)
&
Calculate Residual Dipolar Coupling (RDC)
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.save:paramagpy.metal.Metal.save}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{save}}}}}({[}fileName{]})
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.sbm_r1:paramagpy.metal.Metal.sbm_r1}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{sbm\_r1}}}}}(position, gamma)
&
Calculate R1 relaxation due to Solomon-Bloembergen-Morgan theory
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.sbm_r2:paramagpy.metal.Metal.sbm_r2}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{sbm\_r2}}}}}(position, gamma)
&
Calculate R2 relaxation due to Solomon-Bloembergen-Morgan theory
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.second_invariant_squared:paramagpy.metal.Metal.second_invariant_squared}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{second\_invariant\_squared}}}}}(t)
&
Calculate the second invariant squared of a tensor.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.set_Jg:paramagpy.metal.Metal.set_Jg}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_Jg}}}}}(J, g)
&
Set the magnetic susceptibility absolute magnitude from J/g.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.set_lanthanide:paramagpy.metal.Metal.set_lanthanide}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_lanthanide}}}}}(lanthanide{[}, set\_dchi{]})
&
Set the anisotropy, isotropy and T1e parameters from literature values
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.set_params:paramagpy.metal.Metal.set_params}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_params}}}}}(paramValues)
&
Set tensor parameters that have been scaled appropriately
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.set_utr:paramagpy.metal.Metal.set_utr}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_utr}}}}}()
&
Modify current tensor parameters to unique tensor representation (UTR)
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.spec_dens:paramagpy.metal.Metal.spec_dens}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{spec\_dens}}}}}(tau, omega)
&
A spectral density function with Lorentzian shape:
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.write_isomap:paramagpy.metal.Metal.write_isomap}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{write\_isomap}}}}}(mesh, bounds{[}, fileName{]})
&
Write a PyMol script to file which allows loading of the isosurface file
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.write_pymol_script:paramagpy.metal.Metal.write_pymol_script}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{write\_pymol\_script}}}}}({[}isoval, surfaceName, …{]})
&
Write a PyMol script to file which allows loading of the isosurface file
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{paramagpy.metal.Metal.atom\_ccr}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.atom_ccr:paramagpy-metal-metal-atom-ccr}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.atom_ccr::doc}}\index{atom\_ccr() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.atom_ccr:paramagpy.metal.Metal.atom_ccr}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{atom\_ccr}}}{\emph{atom}, \emph{atomPartner}}{}
Calculate R2 cross-corelated relaxation due to DDxDSA
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{atom}} ({\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom:paramagpy.protein.CustomAtom}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{paramagpy.protein.CustomAtom}}}}}) \textendash{} the active nuclear spin for which relaxation will be calculated
must have attributes ‘position’ and ‘gamma’

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{atomPartner}} ({\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom:paramagpy.protein.CustomAtom}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{paramagpy.protein.CustomAtom}}}}}) \textendash{} the coupling parnter nuclear spin
must have method ‘dipole\_shift\_tensor’

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{value} \textendash{} the CCR differential line broadening in Hz

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.atom\_pcs}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.atom_pcs:paramagpy-metal-metal-atom-pcs}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.atom_pcs::doc}}\index{atom\_pcs() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.atom_pcs:paramagpy.metal.Metal.atom_pcs}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{atom\_pcs}}}{\emph{atom}, \emph{racs=False}, \emph{rads=False}}{}
Calculate the psuedo-contact shift at the given atom
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{atom}} (\sphinxstyleliteralemphasis{\sphinxupquote{biopython atom object}}) \textendash{} must have ‘position’ attribute

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{racs}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} when True, RACS (residual anisotropic chemical shielding)
correction is included. Default is False

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rads}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} when True, RADS (residual anisotropic dipolar shielding)
correction is included. Defualt is False

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{pcs} \textendash{} the pseudo-contact shift in parts-per-million (ppm)

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.atom\_pre}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.atom_pre:paramagpy-metal-metal-atom-pre}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.atom_pre::doc}}\index{atom\_pre() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.atom_pre:paramagpy.metal.Metal.atom_pre}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{atom\_pre}}}{\emph{atom}, \emph{rtype='r2'}, \emph{dsa=True}, \emph{sbm=True}, \emph{csa=0.0}}{}
Calculate the PRE for an atom
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{atom}} ({\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom:paramagpy.protein.CustomAtom}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{paramagpy.protein.CustomAtom}}}}}) \textendash{} the active nuclear spin for which relaxation will be calculated
must have attributes ‘position’ and ‘gamma’

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rtype}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} either ‘r1’ or ‘r2’, the relaxation type

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dsa}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} when True (defualt), DSA or Curie spin relaxation is included

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sbm}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} when True (defualt), SBM spin relaxation is included

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{csa}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{) }}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} CSA tensor of the spin.
This defualts to 0.0, meaning CSAxDSA crosscorrelation is
not accounted for.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{rate} \textendash{} The PRE rate in /s

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.atom\_rdc}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.atom_rdc:paramagpy-metal-metal-atom-rdc}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.atom_rdc::doc}}\index{atom\_rdc() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.atom_rdc:paramagpy.metal.Metal.atom_rdc}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{atom\_rdc}}}{\emph{atom1}, \emph{atom2}}{}
Calculate the residual dipolar coupling between two atoms
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{atom1}} (\sphinxstyleliteralemphasis{\sphinxupquote{biopython atom object}}) \textendash{} must have ‘position’ and ‘gamma’ attribute

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{atom1}} \textendash{} must have ‘position’ and ‘gamma’ attribute

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{rdc} \textendash{} the RDC values in Hz

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.atom\_set\_position}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.atom_set_position:paramagpy-metal-metal-atom-set-position}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.atom_set_position::doc}}\index{atom\_set\_position() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.atom_set_position:paramagpy.metal.Metal.atom_set_position}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{atom\_set\_position}}}{\emph{atom}}{}
Set the position of the Metal object to that of an atom
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{atom}} (\sphinxstyleliteralemphasis{\sphinxupquote{biopython atom object}}) \textendash{} must have ‘position’ attribute

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.ccr}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.ccr:paramagpy-metal-metal-ccr}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.ccr::doc}}\index{ccr() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.ccr:paramagpy.metal.Metal.ccr}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{ccr}}}{\emph{position}, \emph{gamma}, \emph{dipole\_shift\_tensor}}{}
Calculate R2 cross-corelated relaxation due to DDxDSA

If the metal has an anisotropic magnetic susceptibility, this is
taken into account.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{position}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}) \textendash{} three coordinates (x,y,z)
this is the position of the nuclear spin

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gamma}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} the gyromagnetic ratio of the relaxing spin

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dipole\_shift\_tensor}} (\sphinxstyleliteralemphasis{\sphinxupquote{3x3 array of floats}}) \textendash{} this is the dipole shift tensor arising from
the nuclear spin of the coupling partner

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{value} \textendash{} The R2 differential line broadening rate in /s

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.copy}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.copy:paramagpy-metal-metal-copy}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.copy::doc}}\index{copy() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.copy:paramagpy.metal.Metal.copy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{copy}}}{}{}
Copy the current Metal object to a new instance
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstylestrong{new\_tensor} \textendash{} a new Metal instance with the same parameters

\item[{Return type}] \leavevmode
Metal object

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.dipole\_shift\_tensor}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.dipole_shift_tensor:paramagpy-metal-metal-dipole-shift-tensor}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.dipole_shift_tensor::doc}}\index{dipole\_shift\_tensor() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.dipole_shift_tensor:paramagpy.metal.Metal.dipole_shift_tensor}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{dipole\_shift\_tensor}}}{\emph{position}}{}
Calculate the chemical shift tensor at the given postition

This arises due to the paramagnetic dipole tensor field
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{position}} (\sphinxstyleliteralemphasis{\sphinxupquote{array floats}}) \textendash{} the position (x, y, z) in meters

\item[{Returns}] \leavevmode
\sphinxstylestrong{dipole\_shift\_tensor} \textendash{} the tensor describing chemical shift at the nuclear position

\item[{Return type}] \leavevmode
3x3 array

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.dsa\_r1}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.dsa_r1:paramagpy-metal-metal-dsa-r1}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.dsa_r1::doc}}\index{dsa\_r1() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.dsa_r1:paramagpy.metal.Metal.dsa_r1}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{dsa\_r1}}}{\emph{position}, \emph{gamma}, \emph{csa=0.0}}{}
Calculate R1 relaxation due to Curie Spin

If the metal has an anisotropic magnetic susceptibility, this is
taken into account, resulting in orientation dependent PRE as
predicted by Vega and Fiat. CSA cross-correlated relaxation may
be included by providing an appropriate CSA tensor.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{position}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}) \textendash{} three coordinates (x,y,z) in meters

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gamma}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} the gyromagnetic ratio of the spin

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{csa}} (\sphinxstyleliteralemphasis{\sphinxupquote{3x3 matrix}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} the CSA tensor of the given spin.
This defualts to 0.0, meaning CSAxDSA crosscorrelation is
not accounted for.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{value} \textendash{} The R1 relaxation rate in /s

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.dsa\_r2}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.dsa_r2:paramagpy-metal-metal-dsa-r2}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.dsa_r2::doc}}\index{dsa\_r2() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.dsa_r2:paramagpy.metal.Metal.dsa_r2}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{dsa\_r2}}}{\emph{position}, \emph{gamma}, \emph{csa=0.0}}{}
Calculate R2 relaxation due to Curie Spin

If the metal has an anisotropic magnetic susceptibility, this is
taken into account, resulting in orientation dependent PRE as
predicted by Vega and Fiat. CSA cross-correlated relaxation may
be included by providing an appropriate CSA tensor.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{position}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}) \textendash{} three coordinates (x,y,z)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gamma}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} the gyromagnetic ratio of the spin

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{csa}} (\sphinxstyleliteralemphasis{\sphinxupquote{3x3 matrix}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} the CSA tensor of the given spin.
This defualts to 0.0, meaning CSAxDSA crosscorrelation is
not accounted for.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{value} \textendash{} The R2 relaxation rate in /s

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.fast\_ccr}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_ccr:paramagpy-metal-metal-fast-ccr}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_ccr::doc}}\index{fast\_ccr() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_ccr:paramagpy.metal.Metal.fast_ccr}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{fast\_ccr}}}{\emph{posarray}, \emph{gammaarray}, \emph{dstarray}}{}
Vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.ccr:paramagpy.metal.Metal.ccr}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.ccr()}}}}}

This is generally used for speed in fitting DDxDSA data

If the metal has an anisotropic magnetic susceptibility, this is
taken into account.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{posarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of positions in meters

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gammaarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of gyromagnetic ratios of the spins

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dstarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of nuclear dipole shift tensors arising from
the coupling partners

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{rates} \textendash{} The R2 differential line broadening rates in /s

\item[{Return type}] \leavevmode
array with shape (n,1)

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.fast\_dipole\_shift\_tensor}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_dipole_shift_tensor:paramagpy-metal-metal-fast-dipole-shift-tensor}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_dipole_shift_tensor::doc}}\index{fast\_dipole\_shift\_tensor() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_dipole_shift_tensor:paramagpy.metal.Metal.fast_dipole_shift_tensor}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{fast\_dipole\_shift\_tensor}}}{\emph{posarray}}{}
A vectorised version of
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.dipole_shift_tensor:paramagpy.metal.Metal.dipole_shift_tensor}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.dipole\_shift\_tensor()}}}}}

This is generally used for fast calculations.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{posarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array}}) \textendash{} an array of positions with shape (n,3)

\item[{Returns}] \leavevmode
\sphinxstylestrong{dipole\_shift\_tensor\_array} \textendash{} and array of dipole shift tensors at corresponding positions.
This has shape (n,3,3)

\item[{Return type}] \leavevmode
array

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.fast\_dsa\_r1}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_dsa_r1:paramagpy-metal-metal-fast-dsa-r1}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_dsa_r1::doc}}\index{fast\_dsa\_r1() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_dsa_r1:paramagpy.metal.Metal.fast_dsa_r1}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{fast\_dsa\_r1}}}{\emph{posarray}, \emph{gammaarray}, \emph{csaarray=0.0}}{}
Vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.dsa_r1:paramagpy.metal.Metal.dsa_r1}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.dsa\_r1()}}}}}

This is generally used for speed in fitting PRE data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{posarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of positions in meters

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gammaarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of gyromagnetic ratios of the spins

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{csaarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{m}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{) }}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of CSA tensors of the spins.
This defualts to 0.0, meaning CSAxDSA crosscorrelation is
not accounted for.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{rates} \textendash{} The R1 relaxation rates in /s

\item[{Return type}] \leavevmode
array with shape (n,1)

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.fast\_dsa\_r2}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_dsa_r2:paramagpy-metal-metal-fast-dsa-r2}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_dsa_r2::doc}}\index{fast\_dsa\_r2() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_dsa_r2:paramagpy.metal.Metal.fast_dsa_r2}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{fast\_dsa\_r2}}}{\emph{posarray}, \emph{gammaarray}, \emph{csaarray=0.0}}{}
Vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.dsa_r2:paramagpy.metal.Metal.dsa_r2}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.dsa\_r2()}}}}}

This is generally used for speed in fitting PRE data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{posarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of positions in meters

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gammaarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of gyromagnetic ratios of the spins

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{csaarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{m}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{) }}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of CSA tensors of the spins.
This defualts to 0.0, meaning CSAxDSA crosscorrelation is
not accounted for.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{rates} \textendash{} The R2 relaxation rates in /s

\item[{Return type}] \leavevmode
array with shape (n,1)

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.fast\_first\_invariant\_squared}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_first_invariant_squared:paramagpy-metal-metal-fast-first-invariant-squared}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_first_invariant_squared::doc}}\index{fast\_first\_invariant\_squared() (paramagpy.metal.Metal static method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_first_invariant_squared:paramagpy.metal.Metal.fast_first_invariant_squared}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{fast\_first\_invariant\_squared}}}{\emph{t}}{}
Vectorised version of
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.first_invariant_squared:paramagpy.metal.Metal.first_invariant_squared}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.first\_invariant\_squared()}}}}}

This is generally used for speed in fitting PRE data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{tensorarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of shielding tensors

\item[{Returns}] \leavevmode
\sphinxstylestrong{firstInvariantSquared} \textendash{} the first invariants squared of the tensors

\item[{Return type}] \leavevmode
array with shape (n,1)

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.fast\_pcs}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_pcs:paramagpy-metal-metal-fast-pcs}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_pcs::doc}}\index{fast\_pcs() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_pcs:paramagpy.metal.Metal.fast_pcs}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{fast\_pcs}}}{\emph{posarray}}{}
A vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.pcs:paramagpy.metal.Metal.pcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.pcs()}}}}}

This efficient algorithm calculates the PCSs for an array of
positions and is best used where speed is required for fitting.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{posarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of ‘n’ positions (x, y, z) in meters

\item[{Returns}] \leavevmode
\sphinxstylestrong{pcs} \textendash{} the peudo-contact shift in parts-per-million (ppm)

\item[{Return type}] \leavevmode
array of floats with shape (n,1)

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.fast\_pre}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_pre:paramagpy-metal-metal-fast-pre}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_pre::doc}}\index{fast\_pre() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_pre:paramagpy.metal.Metal.fast_pre}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{fast\_pre}}}{\emph{posarray}, \emph{gammaarray}, \emph{rtype}, \emph{dsa=True}, \emph{sbm=True}, \emph{csaarray=0.0}}{}
Calculate the PRE for a set of spins using Curie and or SBM theory
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{posarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of positions in meters

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gammaarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of gyromagnetic ratios of the spins

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rtype}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} either ‘r1’ or ‘r2’, the relaxation type

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dsa}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} when True (defualt), DSA or Curie spin relaxation is included

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sbm}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} when True (defualt), SBM spin relaxation is included

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{csaarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{m}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{) }}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of CSA tensors of the spins.
This defualts to 0.0, meaning CSAxDSA crosscorrelation is
not accounted for.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{rates} \textendash{} The PRE rates in /s

\item[{Return type}] \leavevmode
array with shape (n,1)

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.fast\_racs}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_racs:paramagpy-metal-metal-fast-racs}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_racs::doc}}\index{fast\_racs() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_racs:paramagpy.metal.Metal.fast_racs}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{fast\_racs}}}{\emph{csaarray}}{}
A vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.racs:paramagpy.metal.Metal.racs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.racs()}}}}}

This is generally used when speed is required for fitting
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{csaarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of chemical shift anisotropy tensors

\item[{Returns}] \leavevmode
\sphinxstylestrong{racs\_array} \textendash{} the residual anisotropic chemical shift in parts-per-million (ppm)

\item[{Return type}] \leavevmode
array of floats with shape (n,1)

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.fast\_rads}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_rads:paramagpy-metal-metal-fast-rads}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_rads::doc}}\index{fast\_rads() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_rads:paramagpy.metal.Metal.fast_rads}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{fast\_rads}}}{\emph{posarray}}{}
A vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.rads:paramagpy.metal.Metal.rads}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.rads()}}}}}

This is generally used when speed is required for fitting
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{posarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} an array of ‘n’ positions (x, y, z) in meters

\item[{Returns}] \leavevmode
\sphinxstylestrong{rads\_array} \textendash{} the residual anisotropic dipole shift in parts-per-million (ppm)

\item[{Return type}] \leavevmode
array of floats with shape (n,1)

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.fast\_rdc}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_rdc:paramagpy-metal-metal-fast-rdc}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_rdc::doc}}\index{fast\_rdc() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_rdc:paramagpy.metal.Metal.fast_rdc}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{fast\_rdc}}}{\emph{vecarray}, \emph{gammaProdArray}}{}
A vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.rdc:paramagpy.metal.Metal.rdc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.rdc()}}}}} method.

This is generally used for speed in fitting RDC data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{vecarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of internuclear vectors in meters

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gammaProdArray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{1}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} the products of gyromagnetic ratios of spins A and B
where each has units of rad/s/T

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{rdc\_array} \textendash{} the RDC values in Hz

\item[{Return type}] \leavevmode
array with shape (n,1)

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.fast\_sbm\_r1}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_sbm_r1:paramagpy-metal-metal-fast-sbm-r1}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_sbm_r1::doc}}\index{fast\_sbm\_r1() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_sbm_r1:paramagpy.metal.Metal.fast_sbm_r1}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{fast\_sbm\_r1}}}{\emph{posarray}, \emph{gammaarray}}{}
Vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.sbm_r1:paramagpy.metal.Metal.sbm_r1}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.sbm\_r1()}}}}}

This is generally used for speed in fitting PRE data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{posarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of positions in meters

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gammaarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of gyromagnetic ratios of the spins

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{rates} \textendash{} The R1 relaxation rates in /s

\item[{Return type}] \leavevmode
array with shape (n,1)

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.fast\_sbm\_r2}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_sbm_r2:paramagpy-metal-metal-fast-sbm-r2}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_sbm_r2::doc}}\index{fast\_sbm\_r2() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_sbm_r2:paramagpy.metal.Metal.fast_sbm_r2}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{fast\_sbm\_r2}}}{\emph{posarray}, \emph{gammaarray}}{}
Vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.sbm_r2:paramagpy.metal.Metal.sbm_r2}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.sbm\_r2()}}}}}

This is generally used for speed in fitting PRE data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{posarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of positions in meters

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gammaarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of gyromagnetic ratios of the spins

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{rates} \textendash{} The R2 relaxation rates in /s

\item[{Return type}] \leavevmode
array with shape (n,1)

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.fast\_second\_invariant\_squared}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_second_invariant_squared:paramagpy-metal-metal-fast-second-invariant-squared}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_second_invariant_squared::doc}}\index{fast\_second\_invariant\_squared() (paramagpy.metal.Metal static method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_second_invariant_squared:paramagpy.metal.Metal.fast_second_invariant_squared}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{fast\_second\_invariant\_squared}}}{\emph{t}}{}
Vectorised version of
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.second_invariant_squared:paramagpy.metal.Metal.second_invariant_squared}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.second\_invariant\_squared()}}}}}

This is generally used for speed in fitting PRE data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{tensorarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of shielding tensors

\item[{Returns}] \leavevmode
\sphinxstylestrong{secondInvariantSquared} \textendash{} the second invariants squared of the tensors

\item[{Return type}] \leavevmode
array with shape (n,1)

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.first\_invariant\_squared}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.first_invariant_squared:paramagpy-metal-metal-first-invariant-squared}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.first_invariant_squared::doc}}\index{first\_invariant\_squared() (paramagpy.metal.Metal static method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.first_invariant_squared:paramagpy.metal.Metal.first_invariant_squared}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{first\_invariant\_squared}}}{\emph{t}}{}
Calculate the antisymmetric contribution to relaxation via the
first invariant of a tensor.

This is required for PRE calculations using the shilding tensor
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{tensor}} (\sphinxstyleliteralemphasis{\sphinxupquote{3x3 matrix}}) \textendash{} a second rank tensor

\item[{Returns}] \leavevmode
\sphinxstylestrong{firstInvariantSquared} \textendash{} the first invariant squared of the shift tensor

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.get\_params}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.get_params:paramagpy-metal-metal-get-params}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.get_params::doc}}\index{get\_params() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.get_params:paramagpy.metal.Metal.get_params}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{get\_params}}}{\emph{params}}{}
Get tensor parameters that have been scaled appropriately

This is often used to get parameter values during fitting where
floating point errors would otherwise occur on the small values
encountered.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{params}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of str}}) \textendash{} each element of the list is a string that corresponds to
an attribute of the Metal to be retrieved.

\item[{Returns}] \leavevmode
\sphinxstylestrong{scaled\_params} \textendash{} a list with respective scaled parameter values from the input.

\item[{Return type}] \leavevmode
list

\end{description}\end{quote}
\subsubsection*{Examples}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{metal} \PYG{o}{=} \PYG{n}{Metal}\PYG{p}{(}\PYG{n}{axrh}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mf}{20E\PYGZhy{}32}\PYG{p}{,} \PYG{l+m+mf}{3E\PYGZhy{}32}\PYG{p}{]}\PYG{p}{,}\PYG{n}{position}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{l+m+mf}{10E\PYGZhy{}10}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5E\PYGZhy{}10}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{metal}\PYG{o}{.}\PYG{n}{get\PYGZus{}params}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ax}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rh}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{[20.0, 3.0, 0.0, 10.0, \PYGZhy{}5.0]}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.info}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.info:paramagpy-metal-metal-info}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.info::doc}}\index{info() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.info:paramagpy.metal.Metal.info}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{info}}}{\emph{comment=True}}{}
Get basic information about the Metal object

This is returned as a string in human readable units
This is also the file format for saving the tensor
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{comment}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} if True, each line has a ‘\#’ placed at the front

\item[{Returns}] \leavevmode
\sphinxstylestrong{information} \textendash{} a string containing basic information about the Metal

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}
\subsubsection*{Examples}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{metal} \PYG{o}{=} \PYG{n}{Metal}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{metal}\PYG{o}{.}\PYG{n}{set\PYGZus{}lanthanide}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Er}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{metal}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{\PYGZsh{} ax    \textbar{} 1E\PYGZhy{}32 m\PYGZca{}3 :   \PYGZhy{}11.600}
\PYG{g+go}{\PYGZsh{} rh    \textbar{} 1E\PYGZhy{}32 m\PYGZca{}3 :    \PYGZhy{}8.600}
\PYG{g+go}{\PYGZsh{} x     \textbar{}   1E\PYGZhy{}10 m :     0.000}
\PYG{g+go}{\PYGZsh{} y     \textbar{}   1E\PYGZhy{}10 m :     0.000}
\PYG{g+go}{\PYGZsh{} z     \textbar{}   1E\PYGZhy{}10 m :     0.000}
\PYG{g+go}{\PYGZsh{} a     \textbar{}       deg :     0.000}
\PYG{g+go}{\PYGZsh{} b     \textbar{}       deg :     0.000}
\PYG{g+go}{\PYGZsh{} g     \textbar{}       deg :     0.000}
\PYG{g+go}{\PYGZsh{} mueff \textbar{}        Bm :     9.581}
\PYG{g+go}{\PYGZsh{} shift \textbar{}       ppm :     0.000}
\PYG{g+go}{\PYGZsh{} B0    \textbar{}         T :    18.790}
\PYG{g+go}{\PYGZsh{} temp  \textbar{}         K :   298.150}
\PYG{g+go}{\PYGZsh{} t1e   \textbar{}        ps :     0.189}
\PYG{g+go}{\PYGZsh{} taur  \textbar{}        ns :     0.000}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.isomap}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.isomap:paramagpy-metal-metal-isomap}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.isomap::doc}}\index{isomap() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.isomap:paramagpy.metal.Metal.isomap}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{isomap}}}{\emph{protein=None}, \emph{isoval=1.0}, \emph{**kwargs}}{}
\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.make\_mesh}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.make_mesh:paramagpy-metal-metal-make-mesh}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.make_mesh::doc}}\index{make\_mesh() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.make_mesh:paramagpy.metal.Metal.make_mesh}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{make\_mesh}}}{\emph{density=2}, \emph{size=40.0}}{}
Construct a 3D grid of points to map an isosurface

This is contained in a cube
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{density}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} the points per Angstrom in the grid

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{size}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} the length of one edge of the cube

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{mesh} (\sphinxstyleemphasis{cubic grid array}) \textendash{} This has shape (n,n,n,3) where n is the number of points
along one edge of the grid. Units are meters

\item {} 
\sphinxstylestrong{bounds} (\sphinxstyleemphasis{tuple (origin, low, high, points)}) \textendash{} This tuple has information about the bounding box

origin : array of floats, the (x,y,z) location of mesh vertex
\begin{description}
\item[{low}] \leavevmode{[}array of ints, the integer location of the first{]}
point in each dimension

\item[{high}] \leavevmode{[}array of ints, the integer location of the last{]}
point in each dimension

\end{description}

points : array of ints, the number of points along each dimension

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.pcs}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.pcs:paramagpy-metal-metal-pcs}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.pcs::doc}}\index{pcs() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.pcs:paramagpy.metal.Metal.pcs}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{pcs}}}{\emph{position}}{}
Calculate the psuedo-contact shift at the given postition
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{position}} (\sphinxstyleliteralemphasis{\sphinxupquote{array floats}}) \textendash{} the position (x, y, z) in meters

\item[{Returns}] \leavevmode
\sphinxstylestrong{pcs} \textendash{} the pseudo-contact shift in parts-per-million (ppm)

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}
\subsubsection*{Examples}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{metal} \PYG{o}{=} \PYG{n}{Metal}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{metal}\PYG{o}{.}\PYG{n}{set\PYGZus{}lanthanide}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Er}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{metal}\PYG{o}{.}\PYG{n}{pcs}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{10E\PYGZhy{}10}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{\PYGZhy{}6.153991132886608}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.pcs\_mesh}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.pcs_mesh:paramagpy-metal-metal-pcs-mesh}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.pcs_mesh::doc}}\index{pcs\_mesh() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.pcs_mesh:paramagpy.metal.Metal.pcs_mesh}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{pcs\_mesh}}}{\emph{mesh}}{}
Calculate a PCS value at each location of cubic grid of points
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} a cubic grid as generated by the method \textless{}make\_mesh\textgreater{}

\item[{Returns}] \leavevmode
\sphinxstylestrong{pcs\_mesh} \textendash{} The same grid shape, with PCS values at the respective locations

\item[{Return type}] \leavevmode
array with shape (n,n,n,1)

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.pre}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.pre:paramagpy-metal-metal-pre}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.pre::doc}}\index{pre() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.pre:paramagpy.metal.Metal.pre}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{pre}}}{\emph{position}, \emph{gamma}, \emph{rtype}, \emph{dsa=True}, \emph{sbm=True}, \emph{csa=0.0}}{}
Calculate the PRE for a set of spins using Curie and or SBM theory
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{position}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}) \textendash{} position in meters

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gamma}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} gyromagnetic ratio of the spin

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rtype}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} either ‘r1’ or ‘r2’, the relaxation type

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dsa}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} when True (defualt), DSA or Curie spin relaxation is included

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sbm}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} when True (defualt), SBM spin relaxation is included

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{csa}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{) }}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} CSA tensor of the spin.
This defualts to 0.0, meaning CSAxDSA crosscorrelation is
not accounted for.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{rate} \textendash{} The PRE rate in /s

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.pre\_mesh}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.pre_mesh:paramagpy-metal-metal-pre-mesh}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.pre_mesh::doc}}\index{pre\_mesh() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.pre_mesh:paramagpy.metal.Metal.pre_mesh}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{pre\_mesh}}}{\emph{mesh}, \emph{gamma=267512897.63847807}, \emph{rtype='r2'}, \emph{dsa=True}, \emph{sbm=True}}{}
Calculate a PRE value at each location of cubic grid of points
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} a cubic grid as generated by the method \textless{}make\_mesh\textgreater{}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gamma}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} the gyromagnetic ratio of the spin

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rtype}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} either ‘r1’ or ‘r2’, the relaxation type

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dsa}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} when True (defualt), DSA or Curie spin relaxation is included

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sbm}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} when True (defualt), SBM spin relaxation is included

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{pre\_mesh} \textendash{} The same grid shape, with PRE values at the respective locations

\item[{Return type}] \leavevmode
array with shape (n,n,n,1)

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.racs}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.racs:paramagpy-metal-metal-racs}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.racs::doc}}\index{racs() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.racs:paramagpy.metal.Metal.racs}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{racs}}}{\emph{csa}}{}
Calculate the residual anisotropic chemical shift at the
given postition.

The partial alignment induced by an anisotropic
magnetic susecptiblity causes the chemical shift tensor at a nuclear
position to average to a value different to the isotropic value.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{csa}} (\sphinxstyleliteralemphasis{\sphinxupquote{3 x 3 array}}) \textendash{} the chemical shift anisotropy tensor

\item[{Returns}] \leavevmode
\sphinxstylestrong{racs} \textendash{} the residual anisotropic chemical shift in parts-per-million (ppm)

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.rads}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.rads:paramagpy-metal-metal-rads}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.rads::doc}}\index{rads() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.rads:paramagpy.metal.Metal.rads}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{rads}}}{\emph{position}}{}
Calculate the residual anisotropic dipolar shift at the
given postition.

The partial alignment induced by an anisotropic
magnetic susecptiblity causes the dipole shift tensor at a nuclear
position to average to a value different to the PCS.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{position}} (\sphinxstyleliteralemphasis{\sphinxupquote{array floats}}) \textendash{} the position (x, y, z) in meters

\item[{Returns}] \leavevmode
\sphinxstylestrong{rads} \textendash{} the residual anisotropic dipole shift in parts-per-million (ppm)

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.rdc}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.rdc:paramagpy-metal-metal-rdc}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.rdc::doc}}\index{rdc() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.rdc:paramagpy.metal.Metal.rdc}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{rdc}}}{\emph{vector}, \emph{gammaProd}}{}
Calculate Residual Dipolar Coupling (RDC)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{vector}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}) \textendash{} internuclear vector (x,y,z) in meters

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gammaProd}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} the product of gyromagnetic ratios of spin A and B
where each has units of rad/s/T

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{rdc} \textendash{} the RDC in Hz

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.save}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.save:paramagpy-metal-metal-save}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.save::doc}}\index{save() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.save:paramagpy.metal.Metal.save}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{save}}}{\emph{fileName='tensor.txt'}}{}
\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.sbm\_r1}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.sbm_r1:paramagpy-metal-metal-sbm-r1}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.sbm_r1::doc}}\index{sbm\_r1() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.sbm_r1:paramagpy.metal.Metal.sbm_r1}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{sbm\_r1}}}{\emph{position}, \emph{gamma}}{}
Calculate R1 relaxation due to Solomon-Bloembergen-Morgan theory
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{position}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}) \textendash{} three coordinates (x,y,z)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gamma}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} the gyromagnetic ratio of the spin

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{value} \textendash{} The R1 relaxation rate in /s

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.sbm\_r2}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.sbm_r2:paramagpy-metal-metal-sbm-r2}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.sbm_r2::doc}}\index{sbm\_r2() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.sbm_r2:paramagpy.metal.Metal.sbm_r2}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{sbm\_r2}}}{\emph{position}, \emph{gamma}}{}
Calculate R2 relaxation due to Solomon-Bloembergen-Morgan theory
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{position}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}) \textendash{} three coordinates (x,y,z)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gamma}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} the gyromagnetic ratio of the spin

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{value} \textendash{} The R2 relaxation rate in /s

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.second\_invariant\_squared}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.second_invariant_squared:paramagpy-metal-metal-second-invariant-squared}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.second_invariant_squared::doc}}\index{second\_invariant\_squared() (paramagpy.metal.Metal static method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.second_invariant_squared:paramagpy.metal.Metal.second_invariant_squared}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{second\_invariant\_squared}}}{\emph{t}}{}
Calculate the second invariant squared of a tensor.

This is required for PRE calculations using the shilding tensor
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{tensor}} (\sphinxstyleliteralemphasis{\sphinxupquote{3x3 matrix}}) \textendash{} a second rank tensor

\item[{Returns}] \leavevmode
\sphinxstylestrong{secondInvariantSquared} \textendash{} the second invariant squared of the shift tensor

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.set\_Jg}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.set_Jg:paramagpy-metal-metal-set-jg}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.set_Jg::doc}}\index{set\_Jg() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.set_Jg:paramagpy.metal.Metal.set_Jg}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{set\_Jg}}}{\emph{J}, \emph{g}}{}
Set the magnetic susceptibility absolute magnitude from J/g.

This is achieved using the following formula:
\begin{equation*}
\begin{split}\mu_{eff}=g\mu_B\sqrt{J(J+1)}\end{split}
\end{equation*}\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{J}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} the total spin angular momentum quantum number

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{g}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} the Lande g-factor

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.set\_lanthanide}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.set_lanthanide:paramagpy-metal-metal-set-lanthanide}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.set_lanthanide::doc}}\index{set\_lanthanide() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.set_lanthanide:paramagpy.metal.Metal.set_lanthanide}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{set\_lanthanide}}}{\emph{lanthanide}, \emph{set\_dchi=True}}{}
Set the anisotropy, isotropy and T1e parameters from
literature values
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{lanthanide}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} \begin{description}
\item[{one of {[}‘Ce’,’Pr’,’Nd’,’Pm’,’Sm’,’Eu’,’Gd’,}] \leavevmode
’Tb’,’Dy’,’Ho’,’Er’,’Tm’,’Yb’{]}

\end{description}


\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{set\_dichi}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} if True (default), the tensor anisotropy is set.
Otherwise only the isotropy and T1e values are set

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.set\_params}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.set_params:paramagpy-metal-metal-set-params}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.set_params::doc}}\index{set\_params() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.set_params:paramagpy.metal.Metal.set_params}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{set\_params}}}{\emph{paramValues}}{}
Set tensor parameters that have been scaled appropriately

This is the inverse of the method \textless{}get\_params\textgreater{}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{paramValues}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of tuple}}) \textendash{} each element is a tuple (variable, value) where ‘variable’
is the string indentifying the attribute to be set, and ‘value’
is the corresponding value

\end{description}\end{quote}
\subsubsection*{Examples}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{metal} \PYG{o}{=} \PYG{n}{Metal}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{metal}\PYG{o}{.}\PYG{n}{set\PYGZus{}params}\PYG{p}{(}\PYG{p}{[}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ax}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mf}{20.0}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rh}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mf}{3.0}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{metal}\PYG{o}{.}\PYG{n}{axrh}
\PYG{g+go}{[2.e\PYGZhy{}31 3.e\PYGZhy{}32]}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.set\_utr}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.set_utr:paramagpy-metal-metal-set-utr}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.set_utr::doc}}\index{set\_utr() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.set_utr:paramagpy.metal.Metal.set_utr}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{set\_utr}}}{}{}
Modify current tensor parameters to unique tensor representation (UTR)

Note that multiple axial/rhombic and euler angles can give congruent
tensors.
This method ensures that identical tensors may always be compared
by using Numbat style representation.

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.spec\_dens}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.spec_dens:paramagpy-metal-metal-spec-dens}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.spec_dens::doc}}\index{spec\_dens() (paramagpy.metal.Metal static method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.spec_dens:paramagpy.metal.Metal.spec_dens}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{spec\_dens}}}{\emph{tau}, \emph{omega}}{}
A spectral density function with Lorentzian shape:
\begin{equation*}
\begin{split}\mathbb{J}(\tau,\omega)=\frac{\tau}{1+(\omega\tau)^2}\end{split}
\end{equation*}\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tau}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} correaltion time

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{omega}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} frequency

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{value} \textendash{} the value of the spectral denstiy

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.write\_isomap}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.write_isomap:paramagpy-metal-metal-write-isomap}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.write_isomap::doc}}\index{write\_isomap() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.write_isomap:paramagpy.metal.Metal.write_isomap}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{write\_isomap}}}{\emph{mesh}, \emph{bounds}, \emph{fileName='isomap.pml.ccp4'}}{}
Write a PyMol script to file which allows loading of the
isosurface file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{3D scalar np.ndarray of floats}}) \textendash{} the scalar field of PCS or PRE values in a cubic grid

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bounds}} (\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{origin}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{low}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{high}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{points}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} as generated by {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.make_mesh:paramagpy.metal.Metal.make_mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.make\_mesh()}}}}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fileName}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} the filename of the isosurface file

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.write\_pymol\_script}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.write_pymol_script:paramagpy-metal-metal-write-pymol-script}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.write_pymol_script::doc}}\index{write\_pymol\_script() (paramagpy.metal.Metal method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.write_pymol_script:paramagpy.metal.Metal.write_pymol_script}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{write\_pymol\_script}}}{\emph{isoval=1.0}, \emph{surfaceName='isomap'}, \emph{scriptName='isomap.pml'}, \emph{meshName='./isomap.pml.ccp4'}, \emph{pdbFile=None}}{}
Write a PyMol script to file which allows loading of the
isosurface file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{isoval}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} the contour level of the isosurface

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{surfaceName}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} the name of the isosurface file within PyMol

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{scriptName}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} the name of the PyMol script to load the tensor isosurface

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{meshName}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} the name of the binary isosurface file

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pdbFile}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} if not \textless{}None\textgreater{}, the file name of the PDB file to be loaded with
the isosurface.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\subsubsection*{Attributes}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.B0_MHz:paramagpy.metal.Metal.B0_MHz}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{B0\_MHz}}}}}
&
1H NMR frequency for the given field in MHz
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.GAMMA:paramagpy.metal.Metal.GAMMA}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{GAMMA}}}}}
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.HBAR:paramagpy.metal.Metal.HBAR}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{HBAR}}}}}
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.K:paramagpy.metal.Metal.K}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{K}}}}}
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.MU0:paramagpy.metal.Metal.MU0}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MU0}}}}}
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.MUB:paramagpy.metal.Metal.MUB}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MUB}}}}}
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.a:paramagpy.metal.Metal.a}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{a}}}}}
&
alpha euler anglue
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.alignment_factor:paramagpy.metal.Metal.alignment_factor}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{alignment\_factor}}}}}
&
Factor for conversion between magnetic susceptibility and alignment tensors
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.ax:paramagpy.metal.Metal.ax}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ax}}}}}
&
axiality
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.b:paramagpy.metal.Metal.b}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{b}}}}}
&
beta euler anglue
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.eigenvalues:paramagpy.metal.Metal.eigenvalues}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{eigenvalues}}}}}
&
The eigenvalues defining the magnitude of the principle axes
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.fit_scaling:paramagpy.metal.Metal.fit_scaling}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fit\_scaling}}}}}
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.g:paramagpy.metal.Metal.g}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{g}}}}}
&
gamma euler anglue
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.iso:paramagpy.metal.Metal.iso}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{iso}}}}}
&
isotropy
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.isotropy:paramagpy.metal.Metal.isotropy}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{isotropy}}}}}
&
The magnidue of the isotropic component of the tensor
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.lanth_axrh:paramagpy.metal.Metal.lanth_axrh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{lanth\_axrh}}}}}
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.lanth_lib:paramagpy.metal.Metal.lanth_lib}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{lanth\_lib}}}}}
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.lower_coords:paramagpy.metal.Metal.lower_coords}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{lower\_coords}}}}}
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.rh:paramagpy.metal.Metal.rh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{rh}}}}}
&
rhombicity
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.rotationMatrix:paramagpy.metal.Metal.rotationMatrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{rotationMatrix}}}}}
&
The rotation matrix as defined by the euler angles
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.saupe_factor:paramagpy.metal.Metal.saupe_factor}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{saupe\_factor}}}}}
&
Factor for conversion between magnetic susceptibility and saupe tensors
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.tauc:paramagpy.metal.Metal.tauc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tauc}}}}}
&
The effective rotational correlation time.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.tensor:paramagpy.metal.Metal.tensor}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tensor}}}}}
&
The magnetic susceptibility tensor matrix representation
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.tensor_alignment:paramagpy.metal.Metal.tensor_alignment}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tensor\_alignment}}}}}
&
The alignment tensor matrix representation
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.tensor_saupe:paramagpy.metal.Metal.tensor_saupe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tensor\_saupe}}}}}
&
The saupe tensor matrix representation
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.tensor_traceless:paramagpy.metal.Metal.tensor_traceless}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tensor\_traceless}}}}}
&
The traceless magnetic susceptibility tensor matrix representation
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.upper_coords:paramagpy.metal.Metal.upper_coords}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{upper\_coords}}}}}
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.upper_triang:paramagpy.metal.Metal.upper_triang}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{upper\_triang}}}}}
&
Fetch 5 unique matrix element defining the magnetic susceptibility tensor
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.upper_triang_alignment:paramagpy.metal.Metal.upper_triang_alignment}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{upper\_triang\_alignment}}}}}
&
Fetch 5 unique matrix element defining the alignment tensor
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.upper_triang_saupe:paramagpy.metal.Metal.upper_triang_saupe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{upper\_triang\_saupe}}}}}
&
Fetch 5 unique matrix element defining the magnetic susceptibility tensor
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.x:paramagpy.metal.Metal.x}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{x}}}}}
&
x coordinate
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.y:paramagpy.metal.Metal.y}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{y}}}}}
&
y coordinate
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.z:paramagpy.metal.Metal.z}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{z}}}}}
&
z coordinate
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{paramagpy.metal.Metal.B0\_MHz}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.B0_MHz:paramagpy-metal-metal-b0-mhz}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.B0_MHz::doc}}\index{B0\_MHz (paramagpy.metal.Metal attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.B0_MHz:paramagpy.metal.Metal.B0_MHz}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{B0\_MHz}}}
1H NMR frequency for the given field in MHz

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.GAMMA}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.GAMMA:paramagpy-metal-metal-gamma}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.GAMMA::doc}}\index{GAMMA (paramagpy.metal.Metal attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.GAMMA:paramagpy.metal.Metal.GAMMA}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{GAMMA}}\sphinxbfcode{\sphinxupquote{ = 176085964400.0}}}
\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.HBAR}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.HBAR:paramagpy-metal-metal-hbar}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.HBAR::doc}}\index{HBAR (paramagpy.metal.Metal attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.HBAR:paramagpy.metal.Metal.HBAR}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{HBAR}}\sphinxbfcode{\sphinxupquote{ = 1.0546e-34}}}
\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.K}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.K:paramagpy-metal-metal-k}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.K::doc}}\index{K (paramagpy.metal.Metal attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.K:paramagpy.metal.Metal.K}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{K}}\sphinxbfcode{\sphinxupquote{ = 1.381e-23}}}
\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.MU0}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.MU0:paramagpy-metal-metal-mu0}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.MU0::doc}}\index{MU0 (paramagpy.metal.Metal attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.MU0:paramagpy.metal.Metal.MU0}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{MU0}}\sphinxbfcode{\sphinxupquote{ = 1.2566370614359173e-06}}}
\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.MUB}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.MUB:paramagpy-metal-metal-mub}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.MUB::doc}}\index{MUB (paramagpy.metal.Metal attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.MUB:paramagpy.metal.Metal.MUB}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{MUB}}\sphinxbfcode{\sphinxupquote{ = 9.274e-24}}}
\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.a}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.a:paramagpy-metal-metal-a}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.a::doc}}\index{a (paramagpy.metal.Metal attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.a:paramagpy.metal.Metal.a}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{a}}}
alpha euler anglue

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.alignment\_factor}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.alignment_factor:paramagpy-metal-metal-alignment-factor}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.alignment_factor::doc}}\index{alignment\_factor (paramagpy.metal.Metal attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.alignment_factor:paramagpy.metal.Metal.alignment_factor}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{alignment\_factor}}}
Factor for conversion between magnetic susceptibility
and alignment tensors

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.ax}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.ax:paramagpy-metal-metal-ax}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.ax::doc}}\index{ax (paramagpy.metal.Metal attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.ax:paramagpy.metal.Metal.ax}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{ax}}}
axiality

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.b}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.b:paramagpy-metal-metal-b}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.b::doc}}\index{b (paramagpy.metal.Metal attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.b:paramagpy.metal.Metal.b}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{b}}}
beta euler anglue

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.eigenvalues}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.eigenvalues:paramagpy-metal-metal-eigenvalues}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.eigenvalues::doc}}\index{eigenvalues (paramagpy.metal.Metal attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.eigenvalues:paramagpy.metal.Metal.eigenvalues}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{eigenvalues}}}
The eigenvalues defining the magnitude of the principle axes

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.fit\_scaling}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.fit_scaling:paramagpy-metal-metal-fit-scaling}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.fit_scaling::doc}}\index{fit\_scaling (paramagpy.metal.Metal attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.fit_scaling:paramagpy.metal.Metal.fit_scaling}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{fit\_scaling}}\sphinxbfcode{\sphinxupquote{ = \{'a': 57.29577951308232, 'ax': 1e+32, 'b': 57.29577951308232, 'g': 57.29577951308232, 'iso': 1e+32, 'mueff': 1.0782833728703903e+23, 'rh': 1e+32, 't1e': 1000000000000.0, 'taur': 1000000000.0, 'x': 10000000000.0, 'y': 10000000000.0, 'z': 10000000000.0\}}}}
\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.g}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.g:paramagpy-metal-metal-g}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.g::doc}}\index{g (paramagpy.metal.Metal attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.g:paramagpy.metal.Metal.g}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{g}}}
gamma euler anglue

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.iso}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.iso:paramagpy-metal-metal-iso}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.iso::doc}}\index{iso (paramagpy.metal.Metal attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.iso:paramagpy.metal.Metal.iso}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{iso}}}
isotropy

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.isotropy}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.isotropy:paramagpy-metal-metal-isotropy}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.isotropy::doc}}\index{isotropy (paramagpy.metal.Metal attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.isotropy:paramagpy.metal.Metal.isotropy}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{isotropy}}}
The magnidue of the isotropic component of the tensor

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.lanth\_axrh}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.lanth_axrh:paramagpy-metal-metal-lanth-axrh}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.lanth_axrh::doc}}\index{lanth\_axrh (paramagpy.metal.Metal attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.lanth_axrh:paramagpy.metal.Metal.lanth_axrh}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{lanth\_axrh}}\sphinxbfcode{\sphinxupquote{ = \{'Ce': (2.1, 0.7), 'Dy': (34.7, 20.3), 'Er': (-11.6, -8.6), 'Eu': (2.4, 1.5), 'Gd': (0.0, 0.0), 'Ho': (18.5, 5.8), 'Nd': (1.7, 0.4), 'Pm': (0.0, 0.0), 'Pr': (3.4, 2.1), 'Sm': (0.2, 0.1), 'Tb': (42.1, 11.2), 'Tm': (-21.9, -20.1), 'Yb': (-8.3, -5.8), 'Zero': (0.0, 0.0)\}}}}
\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.lanth\_lib}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.lanth_lib:paramagpy-metal-metal-lanth-lib}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.lanth_lib::doc}}\index{lanth\_lib (paramagpy.metal.Metal attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.lanth_lib:paramagpy.metal.Metal.lanth_lib}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{lanth\_lib}}\sphinxbfcode{\sphinxupquote{ = \{'Ce': (2.5, 0.8571428571428571, 1.33e-13), 'Dy': (7.5, 1.3333333333333333, 2.4e-13), 'Er': (7.5, 1.2, 1.89e-13), 'Eu': (2.0, 1.5, 1.5e-14), 'Gd': (3.5, 2.0, nan), 'Ho': (8.0, 1.25, 2.09e-13), 'Nd': (4.5, 0.7272727272727273, 2.1e-13), 'Pm': (4.0, 0.6, nan), 'Pr': (4.0, 0.8, 5.4e-14), 'Sm': (2.5, 0.2857142857142857, 7.4e-14), 'Tb': (6.0, 1.5, 2.51e-13), 'Tm': (6.0, 1.1666666666666667, 2.68e-13), 'Yb': (3.5, 1.1428571428571428, 1.57e-13), 'Zero': (0.0, 0.0, 0.0)\}}}}
\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.lower\_coords}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.lower_coords:paramagpy-metal-metal-lower-coords}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.lower_coords::doc}}\index{lower\_coords (paramagpy.metal.Metal attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.lower_coords:paramagpy.metal.Metal.lower_coords}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{lower\_coords}}\sphinxbfcode{\sphinxupquote{ = ((0, 1, 1, 2, 2), (0, 1, 0, 0, 1))}}}
\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.rh}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.rh:paramagpy-metal-metal-rh}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.rh::doc}}\index{rh (paramagpy.metal.Metal attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.rh:paramagpy.metal.Metal.rh}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{rh}}}
rhombicity

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.rotationMatrix}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.rotationMatrix:paramagpy-metal-metal-rotationmatrix}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.rotationMatrix::doc}}\index{rotationMatrix (paramagpy.metal.Metal attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.rotationMatrix:paramagpy.metal.Metal.rotationMatrix}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{rotationMatrix}}}
The rotation matrix as defined by the euler angles

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.saupe\_factor}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.saupe_factor:paramagpy-metal-metal-saupe-factor}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.saupe_factor::doc}}\index{saupe\_factor (paramagpy.metal.Metal attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.saupe_factor:paramagpy.metal.Metal.saupe_factor}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{saupe\_factor}}}
Factor for conversion between magnetic susceptibility
and saupe tensors

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.tauc}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.tauc:paramagpy-metal-metal-tauc}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.tauc::doc}}\index{tauc (paramagpy.metal.Metal attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.tauc:paramagpy.metal.Metal.tauc}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{tauc}}}
The effective rotational correlation time.

This is calculated by combining the rotational correaltion time
and the electronic relaxation time:
\begin{equation*}
\begin{split}\tau_c = \frac{1}{\frac{1}{\tau_r}+\frac{1}{T_{1e}}}\end{split}
\end{equation*}
\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.tensor}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.tensor:paramagpy-metal-metal-tensor}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.tensor::doc}}\index{tensor (paramagpy.metal.Metal attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.tensor:paramagpy.metal.Metal.tensor}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{tensor}}}
The magnetic susceptibility tensor matrix representation

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.tensor\_alignment}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.tensor_alignment:paramagpy-metal-metal-tensor-alignment}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.tensor_alignment::doc}}\index{tensor\_alignment (paramagpy.metal.Metal attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.tensor_alignment:paramagpy.metal.Metal.tensor_alignment}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{tensor\_alignment}}}
The alignment tensor matrix representation

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.tensor\_saupe}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.tensor_saupe:paramagpy-metal-metal-tensor-saupe}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.tensor_saupe::doc}}\index{tensor\_saupe (paramagpy.metal.Metal attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.tensor_saupe:paramagpy.metal.Metal.tensor_saupe}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{tensor\_saupe}}}
The saupe tensor matrix representation

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.tensor\_traceless}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.tensor_traceless:paramagpy-metal-metal-tensor-traceless}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.tensor_traceless::doc}}\index{tensor\_traceless (paramagpy.metal.Metal attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.tensor_traceless:paramagpy.metal.Metal.tensor_traceless}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{tensor\_traceless}}}
The traceless magnetic susceptibility tensor matrix representation

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.upper\_coords}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.upper_coords:paramagpy-metal-metal-upper-coords}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.upper_coords::doc}}\index{upper\_coords (paramagpy.metal.Metal attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.upper_coords:paramagpy.metal.Metal.upper_coords}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{upper\_coords}}\sphinxbfcode{\sphinxupquote{ = ((0, 1, 0, 0, 1), (0, 1, 1, 2, 2))}}}
\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.upper\_triang}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.upper_triang:paramagpy-metal-metal-upper-triang}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.upper_triang::doc}}\index{upper\_triang (paramagpy.metal.Metal attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.upper_triang:paramagpy.metal.Metal.upper_triang}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{upper\_triang}}}
Fetch 5 unique matrix element defining the magnetic
susceptibility tensor

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.upper\_triang\_alignment}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.upper_triang_alignment:paramagpy-metal-metal-upper-triang-alignment}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.upper_triang_alignment::doc}}\index{upper\_triang\_alignment (paramagpy.metal.Metal attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.upper_triang_alignment:paramagpy.metal.Metal.upper_triang_alignment}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{upper\_triang\_alignment}}}
Fetch 5 unique matrix element defining the alignment tensor

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.upper\_triang\_saupe}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.upper_triang_saupe:paramagpy-metal-metal-upper-triang-saupe}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.upper_triang_saupe::doc}}\index{upper\_triang\_saupe (paramagpy.metal.Metal attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.upper_triang_saupe:paramagpy.metal.Metal.upper_triang_saupe}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{upper\_triang\_saupe}}}
Fetch 5 unique matrix element defining the magnetic
susceptibility tensor

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.x}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.x:paramagpy-metal-metal-x}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.x::doc}}\index{x (paramagpy.metal.Metal attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.x:paramagpy.metal.Metal.x}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{x}}}
x coordinate

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.y}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.y:paramagpy-metal-metal-y}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.y::doc}}\index{y (paramagpy.metal.Metal attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.y:paramagpy.metal.Metal.y}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{y}}}
y coordinate

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.z}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.z:paramagpy-metal-metal-z}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.z::doc}}\index{z (paramagpy.metal.Metal attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.z:paramagpy.metal.Metal.z}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{z}}}
z coordinate

\end{fulllineitems}


\end{fulllineitems}


\end{fulllineitems}



\subsection{Protein module}
\label{\detokenize{reference/index:protein-module}}
This module handles the protein structure coordinates and includes methods for
loading a PDB file and calculating atomic properites such as CSA or gyromagnetic ratio


\subsubsection{paramagpy.protein}
\label{\detokenize{reference/protein:module-paramagpy.protein}}\label{\detokenize{reference/protein:paramagpy-protein}}\label{\detokenize{reference/protein:protein}}\label{\detokenize{reference/protein::doc}}\index{paramagpy.protein (module)}

\paragraph{Functions}
\label{\detokenize{reference/protein:functions}}

\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{reference/generated/paramagpy.protein.load_pdb:paramagpy.protein.load_pdb}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{load\_pdb}}}}}(fileName{[}, ident{]})
&
Read PDB from file into biopython structure object
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.rotation_matrix:paramagpy.protein.rotation_matrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{rotation\_matrix}}}}}(axis, theta)
&
Return the rotation matrix associated with counterclockwise rotation about the given axis by theta radians.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{paramagpy.protein.load\_pdb}
\label{\detokenize{reference/generated/paramagpy.protein.load_pdb:paramagpy-protein-load-pdb}}\label{\detokenize{reference/generated/paramagpy.protein.load_pdb::doc}}\index{load\_pdb() (in module paramagpy.protein)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.load_pdb:paramagpy.protein.load_pdb}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.protein.}}\sphinxbfcode{\sphinxupquote{load\_pdb}}}{\emph{fileName}, \emph{ident=None}}{}
Read PDB from file into biopython structure object
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fileName}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} the path to the file

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ident}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} the desired identity of the structure object

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{values} \textendash{} a structure object containing the atomic coordinates

\item[{Return type}] \leavevmode
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure:paramagpy.protein.CustomStructure}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.protein.CustomStructure}}}}}

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.protein.rotation\_matrix}
\label{\detokenize{reference/generated/paramagpy.protein.rotation_matrix:paramagpy-protein-rotation-matrix}}\label{\detokenize{reference/generated/paramagpy.protein.rotation_matrix::doc}}\index{rotation\_matrix() (in module paramagpy.protein)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.rotation_matrix:paramagpy.protein.rotation_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.protein.}}\sphinxbfcode{\sphinxupquote{rotation\_matrix}}}{\emph{axis}, \emph{theta}}{}
Return the rotation matrix associated with counterclockwise
rotation about the given axis by theta radians.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{axis}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}) \textendash{} the {[}x,y,z{]} axis for rotation.

\item[{Returns}] \leavevmode
\sphinxstylestrong{matrix} \textendash{} the rotation matrix

\item[{Return type}] \leavevmode
numpy 3x3 matrix object

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{Classes}
\label{\detokenize{reference/protein:classes}}

\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom:paramagpy.protein.CustomAtom}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CustomAtom}}}}}(*arg, **kwargs)
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure:paramagpy.protein.CustomStructure}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CustomStructure}}}}}(*arg, **kwargs)
&
This is an overload hack of the BioPython Structure object
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder:paramagpy.protein.CustomStructureBuilder}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CustomStructureBuilder}}}}}(*arg, **kwargs)
&
This is an overload hack of BioPython’s CustomStructureBuilder
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{paramagpy.protein.CustomAtom}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom:paramagpy-protein-customatom}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom::doc}}\index{CustomAtom (class in paramagpy.protein)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom:paramagpy.protein.CustomAtom}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{paramagpy.protein.}}\sphinxbfcode{\sphinxupquote{CustomAtom}}}{\emph{*arg}, \emph{**kwargs}}{}~\index{\_\_init\_\_() (paramagpy.protein.CustomAtom method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom:paramagpy.protein.CustomAtom.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{*arg}, \emph{**kwargs}}{}
Create Atom object.

The Atom object stores atom name (both with and without spaces),
coordinates, B factor, occupancy, alternative location specifier
and (optionally) anisotropic B factor and standard deviations of
B factor and positions.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} atom name (eg. “CA”). Note that spaces are normally stripped.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coord}} (\sphinxstyleliteralemphasis{\sphinxupquote{Numeric array}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{Float0}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{size 3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} atomic coordinates (x,y,z)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bfactor}} (\sphinxstyleliteralemphasis{\sphinxupquote{number}}) \textendash{} isotropic B factor

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{occupancy}} (\sphinxstyleliteralemphasis{\sphinxupquote{number}}) \textendash{} occupancy (0.0-1.0)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{altloc}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} alternative location specifier for disordered atoms

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fullname}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} full atom name, including spaces, e.g. ” CA “. Normally
these spaces are stripped from the atom name.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{element}} (\sphinxstyleliteralemphasis{\sphinxupquote{uppercase string}}\sphinxstyleliteralemphasis{\sphinxupquote{ (or }}\sphinxstyleliteralemphasis{\sphinxupquote{None if unknown}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} atom element, e.g. “C” for Carbon, “HG” for mercury,

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.copy:paramagpy.protein.CustomAtom.copy}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{copy}}}}}()
&
Create a copy of the Atom.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.detach_parent:paramagpy.protein.CustomAtom.detach_parent}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{detach\_parent}}}}}()
&
Remove reference to parent.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.dipole_shift_tensor:paramagpy.protein.CustomAtom.dipole_shift_tensor}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dipole\_shift\_tensor}}}}}(position)
&
Calculate the magnetic field shielding tensor at the given postition due to the nuclear dipole
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.flag_disorder:paramagpy.protein.CustomAtom.flag_disorder}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{flag\_disorder}}}}}()
&
Set the disordered flag to 1.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_altloc:paramagpy.protein.CustomAtom.get_altloc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_altloc}}}}}()
&
Return alternative location specifier.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_anisou:paramagpy.protein.CustomAtom.get_anisou}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_anisou}}}}}()
&
Return anisotropic B factor.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_bfactor:paramagpy.protein.CustomAtom.get_bfactor}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_bfactor}}}}}()
&
Return B factor.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_coord:paramagpy.protein.CustomAtom.get_coord}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_coord}}}}}()
&
Return atomic coordinates.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_full_id:paramagpy.protein.CustomAtom.get_full_id}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_full\_id}}}}}()
&
Return the full id of the atom.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_fullname:paramagpy.protein.CustomAtom.get_fullname}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_fullname}}}}}()
&
Return the atom name, including leading and trailing spaces.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_id:paramagpy.protein.CustomAtom.get_id}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_id}}}}}()
&
Return the id of the atom (which is its atom name).
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_level:paramagpy.protein.CustomAtom.get_level}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_level}}}}}()
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_name:paramagpy.protein.CustomAtom.get_name}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_name}}}}}()
&
Return atom name.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_occupancy:paramagpy.protein.CustomAtom.get_occupancy}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_occupancy}}}}}()
&
Return occupancy.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_parent:paramagpy.protein.CustomAtom.get_parent}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_parent}}}}}()
&
Return parent residue.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_serial_number:paramagpy.protein.CustomAtom.get_serial_number}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_serial\_number}}}}}()
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_sigatm:paramagpy.protein.CustomAtom.get_sigatm}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_sigatm}}}}}()
&
Return standard deviation of atomic parameters.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_siguij:paramagpy.protein.CustomAtom.get_siguij}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_siguij}}}}}()
&
Return standard deviations of anisotropic temperature factors.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_vector:paramagpy.protein.CustomAtom.get_vector}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_vector}}}}}()
&
Return coordinates as Vector.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.is_disordered:paramagpy.protein.CustomAtom.is_disordered}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{is\_disordered}}}}}()
&
Return the disordered flag (1 if disordered, 0 otherwise).
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_altloc:paramagpy.protein.CustomAtom.set_altloc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_altloc}}}}}(altloc)
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_anisou:paramagpy.protein.CustomAtom.set_anisou}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_anisou}}}}}(anisou\_array)
&
Set anisotropic B factor.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_bfactor:paramagpy.protein.CustomAtom.set_bfactor}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_bfactor}}}}}(bfactor)
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_coord:paramagpy.protein.CustomAtom.set_coord}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_coord}}}}}(coord)
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_occupancy:paramagpy.protein.CustomAtom.set_occupancy}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_occupancy}}}}}(occupancy)
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_parent:paramagpy.protein.CustomAtom.set_parent}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_parent}}}}}(parent)
&
Set the parent residue.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_serial_number:paramagpy.protein.CustomAtom.set_serial_number}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_serial\_number}}}}}(n)
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_sigatm:paramagpy.protein.CustomAtom.set_sigatm}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_sigatm}}}}}(sigatm\_array)
&
Set standard deviation of atomic parameters.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_siguij:paramagpy.protein.CustomAtom.set_siguij}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_siguij}}}}}(siguij\_array)
&
Set standard deviations of anisotropic temperature factors.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.top:paramagpy.protein.CustomAtom.top}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{top}}}}}()
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.transform:paramagpy.protein.CustomAtom.transform}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{transform}}}}}(rot, tran)
&
Apply rotation and translation to the atomic coordinates.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{paramagpy.protein.CustomAtom.copy}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.copy:paramagpy-protein-customatom-copy}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.copy::doc}}\index{copy() (paramagpy.protein.CustomAtom method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.copy:paramagpy.protein.CustomAtom.copy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{copy}}}{}{}
Create a copy of the Atom.

Parent information is lost.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.detach\_parent}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.detach_parent:paramagpy-protein-customatom-detach-parent}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.detach_parent::doc}}\index{detach\_parent() (paramagpy.protein.CustomAtom method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.detach_parent:paramagpy.protein.CustomAtom.detach_parent}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{detach\_parent}}}{}{}
Remove reference to parent.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.dipole\_shift\_tensor}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.dipole_shift_tensor:paramagpy-protein-customatom-dipole-shift-tensor}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.dipole_shift_tensor::doc}}\index{dipole\_shift\_tensor() (paramagpy.protein.CustomAtom method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.dipole_shift_tensor:paramagpy.protein.CustomAtom.dipole_shift_tensor}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{dipole\_shift\_tensor}}}{\emph{position}}{}
Calculate the magnetic field shielding tensor at the given postition
due to the nuclear dipole

Assumes nuclear spin 1/2
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{position}} (\sphinxstyleliteralemphasis{\sphinxupquote{array floats}}) \textendash{} the position (x, y, z) in meters

\item[{Returns}] \leavevmode
\sphinxstylestrong{dipole\_shielding\_tensor} \textendash{} the tensor describing magnetic shielding at the given position

\item[{Return type}] \leavevmode
3x3 array

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.flag\_disorder}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.flag_disorder:paramagpy-protein-customatom-flag-disorder}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.flag_disorder::doc}}\index{flag\_disorder() (paramagpy.protein.CustomAtom method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.flag_disorder:paramagpy.protein.CustomAtom.flag_disorder}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{flag\_disorder}}}{}{}
Set the disordered flag to 1.

The disordered flag indicates whether the atom is disordered or not.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.get\_altloc}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_altloc:paramagpy-protein-customatom-get-altloc}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_altloc::doc}}\index{get\_altloc() (paramagpy.protein.CustomAtom method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_altloc:paramagpy.protein.CustomAtom.get_altloc}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{get\_altloc}}}{}{}
Return alternative location specifier.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.get\_anisou}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_anisou:paramagpy-protein-customatom-get-anisou}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_anisou::doc}}\index{get\_anisou() (paramagpy.protein.CustomAtom method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_anisou:paramagpy.protein.CustomAtom.get_anisou}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{get\_anisou}}}{}{}
Return anisotropic B factor.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.get\_bfactor}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_bfactor:paramagpy-protein-customatom-get-bfactor}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_bfactor::doc}}\index{get\_bfactor() (paramagpy.protein.CustomAtom method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_bfactor:paramagpy.protein.CustomAtom.get_bfactor}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{get\_bfactor}}}{}{}
Return B factor.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.get\_coord}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_coord:paramagpy-protein-customatom-get-coord}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_coord::doc}}\index{get\_coord() (paramagpy.protein.CustomAtom method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_coord:paramagpy.protein.CustomAtom.get_coord}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{get\_coord}}}{}{}
Return atomic coordinates.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.get\_full\_id}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_full_id:paramagpy-protein-customatom-get-full-id}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_full_id::doc}}\index{get\_full\_id() (paramagpy.protein.CustomAtom method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_full_id:paramagpy.protein.CustomAtom.get_full_id}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{get\_full\_id}}}{}{}
Return the full id of the atom.

The full id of an atom is the tuple
(structure id, model id, chain id, residue id, atom name, altloc).

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.get\_fullname}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_fullname:paramagpy-protein-customatom-get-fullname}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_fullname::doc}}\index{get\_fullname() (paramagpy.protein.CustomAtom method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_fullname:paramagpy.protein.CustomAtom.get_fullname}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{get\_fullname}}}{}{}
Return the atom name, including leading and trailing spaces.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.get\_id}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_id:paramagpy-protein-customatom-get-id}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_id::doc}}\index{get\_id() (paramagpy.protein.CustomAtom method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_id:paramagpy.protein.CustomAtom.get_id}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{get\_id}}}{}{}
Return the id of the atom (which is its atom name).

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.get\_level}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_level:paramagpy-protein-customatom-get-level}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_level::doc}}\index{get\_level() (paramagpy.protein.CustomAtom method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_level:paramagpy.protein.CustomAtom.get_level}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{get\_level}}}{}{}
\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.get\_name}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_name:paramagpy-protein-customatom-get-name}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_name::doc}}\index{get\_name() (paramagpy.protein.CustomAtom method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_name:paramagpy.protein.CustomAtom.get_name}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{get\_name}}}{}{}
Return atom name.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.get\_occupancy}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_occupancy:paramagpy-protein-customatom-get-occupancy}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_occupancy::doc}}\index{get\_occupancy() (paramagpy.protein.CustomAtom method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_occupancy:paramagpy.protein.CustomAtom.get_occupancy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{get\_occupancy}}}{}{}
Return occupancy.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.get\_parent}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_parent:paramagpy-protein-customatom-get-parent}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_parent::doc}}\index{get\_parent() (paramagpy.protein.CustomAtom method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_parent:paramagpy.protein.CustomAtom.get_parent}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{get\_parent}}}{}{}
Return parent residue.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.get\_serial\_number}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_serial_number:paramagpy-protein-customatom-get-serial-number}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_serial_number::doc}}\index{get\_serial\_number() (paramagpy.protein.CustomAtom method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_serial_number:paramagpy.protein.CustomAtom.get_serial_number}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{get\_serial\_number}}}{}{}
\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.get\_sigatm}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_sigatm:paramagpy-protein-customatom-get-sigatm}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_sigatm::doc}}\index{get\_sigatm() (paramagpy.protein.CustomAtom method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_sigatm:paramagpy.protein.CustomAtom.get_sigatm}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{get\_sigatm}}}{}{}
Return standard deviation of atomic parameters.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.get\_siguij}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_siguij:paramagpy-protein-customatom-get-siguij}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_siguij::doc}}\index{get\_siguij() (paramagpy.protein.CustomAtom method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_siguij:paramagpy.protein.CustomAtom.get_siguij}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{get\_siguij}}}{}{}
Return standard deviations of anisotropic temperature factors.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.get\_vector}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_vector:paramagpy-protein-customatom-get-vector}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_vector::doc}}\index{get\_vector() (paramagpy.protein.CustomAtom method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_vector:paramagpy.protein.CustomAtom.get_vector}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{get\_vector}}}{}{}
Return coordinates as Vector.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
coordinates as 3D vector

\item[{Return type}] \leavevmode
Bio.PDB.Vector class

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.is\_disordered}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.is_disordered:paramagpy-protein-customatom-is-disordered}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.is_disordered::doc}}\index{is\_disordered() (paramagpy.protein.CustomAtom method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.is_disordered:paramagpy.protein.CustomAtom.is_disordered}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{is\_disordered}}}{}{}
Return the disordered flag (1 if disordered, 0 otherwise).

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.set\_altloc}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_altloc:paramagpy-protein-customatom-set-altloc}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_altloc::doc}}\index{set\_altloc() (paramagpy.protein.CustomAtom method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_altloc:paramagpy.protein.CustomAtom.set_altloc}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{set\_altloc}}}{\emph{altloc}}{}
\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.set\_anisou}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_anisou:paramagpy-protein-customatom-set-anisou}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_anisou::doc}}\index{set\_anisou() (paramagpy.protein.CustomAtom method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_anisou:paramagpy.protein.CustomAtom.set_anisou}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{set\_anisou}}}{\emph{anisou\_array}}{}
Set anisotropic B factor.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{anisou\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{Numeric array}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{length 6}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} anisotropic B factor.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.set\_bfactor}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_bfactor:paramagpy-protein-customatom-set-bfactor}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_bfactor::doc}}\index{set\_bfactor() (paramagpy.protein.CustomAtom method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_bfactor:paramagpy.protein.CustomAtom.set_bfactor}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{set\_bfactor}}}{\emph{bfactor}}{}
\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.set\_coord}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_coord:paramagpy-protein-customatom-set-coord}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_coord::doc}}\index{set\_coord() (paramagpy.protein.CustomAtom method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_coord:paramagpy.protein.CustomAtom.set_coord}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{set\_coord}}}{\emph{coord}}{}
\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.set\_occupancy}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_occupancy:paramagpy-protein-customatom-set-occupancy}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_occupancy::doc}}\index{set\_occupancy() (paramagpy.protein.CustomAtom method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_occupancy:paramagpy.protein.CustomAtom.set_occupancy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{set\_occupancy}}}{\emph{occupancy}}{}
\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.set\_parent}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_parent:paramagpy-protein-customatom-set-parent}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_parent::doc}}\index{set\_parent() (paramagpy.protein.CustomAtom method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_parent:paramagpy.protein.CustomAtom.set_parent}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{set\_parent}}}{\emph{parent}}{}
Set the parent residue.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{parent - Residue object}} (\sphinxstyleliteralemphasis{\sphinxupquote{-}}) \textendash{} 

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.set\_serial\_number}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_serial_number:paramagpy-protein-customatom-set-serial-number}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_serial_number::doc}}\index{set\_serial\_number() (paramagpy.protein.CustomAtom method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_serial_number:paramagpy.protein.CustomAtom.set_serial_number}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{set\_serial\_number}}}{\emph{n}}{}
\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.set\_sigatm}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_sigatm:paramagpy-protein-customatom-set-sigatm}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_sigatm::doc}}\index{set\_sigatm() (paramagpy.protein.CustomAtom method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_sigatm:paramagpy.protein.CustomAtom.set_sigatm}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{set\_sigatm}}}{\emph{sigatm\_array}}{}
Set standard deviation of atomic parameters.

The standard deviation of atomic parameters consists
of 3 positional, 1 B factor and 1 occupancy standard
deviation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{sigatm\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{Numeric array}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{length 5}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} standard deviations of atomic parameters.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.set\_siguij}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_siguij:paramagpy-protein-customatom-set-siguij}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_siguij::doc}}\index{set\_siguij() (paramagpy.protein.CustomAtom method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_siguij:paramagpy.protein.CustomAtom.set_siguij}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{set\_siguij}}}{\emph{siguij\_array}}{}
Set standard deviations of anisotropic temperature factors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{siguij\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{Numeric array}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{length 6}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} standard deviations of anisotropic temperature factors.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.top}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.top:paramagpy-protein-customatom-top}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.top::doc}}\index{top() (paramagpy.protein.CustomAtom method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.top:paramagpy.protein.CustomAtom.top}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{top}}}{}{}
\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.transform}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.transform:paramagpy-protein-customatom-transform}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.transform::doc}}\index{transform() (paramagpy.protein.CustomAtom method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.transform:paramagpy.protein.CustomAtom.transform}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{transform}}}{\emph{rot}, \emph{tran}}{}
Apply rotation and translation to the atomic coordinates.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rot}} (\sphinxstyleliteralemphasis{\sphinxupquote{3x3 Numeric array}}) \textendash{} A right multiplying rotation matrix

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tran}} (\sphinxstyleliteralemphasis{\sphinxupquote{size 3 Numeric array}}) \textendash{} the translation vector

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Examples}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rotation}\PYG{o}{=}\PYG{n}{rotmat}\PYG{p}{(}\PYG{n}{pi}\PYG{p}{,} \PYG{n}{Vector}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{translation}\PYG{o}{=}\PYG{n}{array}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{atom}\PYG{o}{.}\PYG{n}{transform}\PYG{p}{(}\PYG{n}{rotation}\PYG{p}{,} \PYG{n}{translation}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\subsubsection*{Attributes}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.HBAR:paramagpy.protein.CustomAtom.HBAR}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{HBAR}}}}}
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.MU0:paramagpy.protein.CustomAtom.MU0}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MU0}}}}}
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.csa:paramagpy.protein.CustomAtom.csa}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{csa}}}}}
&
Get the CSA tensor at the nuclear position This uses the geometry of neighbouring atoms and a standard library from Bax J.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.csa_lib:paramagpy.protein.CustomAtom.csa_lib}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{csa\_lib}}}}}
&
docstring for CustomAtom
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.gyro_lib:paramagpy.protein.CustomAtom.gyro_lib}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gyro\_lib}}}}}
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.position:paramagpy.protein.CustomAtom.position}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{position}}}}}
&

\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{paramagpy.protein.CustomAtom.HBAR}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.HBAR:paramagpy-protein-customatom-hbar}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.HBAR::doc}}\index{HBAR (paramagpy.protein.CustomAtom attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.HBAR:paramagpy.protein.CustomAtom.HBAR}}\pysigline{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{HBAR}}\sphinxbfcode{\sphinxupquote{ = 1.0546e-34}}}
\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.MU0}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.MU0:paramagpy-protein-customatom-mu0}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.MU0::doc}}\index{MU0 (paramagpy.protein.CustomAtom attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.MU0:paramagpy.protein.CustomAtom.MU0}}\pysigline{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{MU0}}\sphinxbfcode{\sphinxupquote{ = 1.2566370614359173e-06}}}
\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.csa}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.csa:paramagpy-protein-customatom-csa}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.csa::doc}}\index{csa (paramagpy.protein.CustomAtom attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.csa:paramagpy.protein.CustomAtom.csa}}\pysigline{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{csa}}}
Get the CSA tensor at the nuclear position
This uses the geometry of neighbouring atoms
and a standard library from Bax J. Am. Chem. Soc. 2000
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstylestrong{matrix} \textendash{} the CSA tensor in the PDB frame
if appropriate nuclear positions are not
available \textless{}None\textgreater{} is returned.

\item[{Return type}] \leavevmode
3x3 array

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.csa\_lib}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.csa_lib:paramagpy-protein-customatom-csa-lib}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.csa_lib::doc}}\index{csa\_lib (paramagpy.protein.CustomAtom attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.csa_lib:paramagpy.protein.CustomAtom.csa_lib}}\pysigline{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{csa\_lib}}\sphinxbfcode{\sphinxupquote{ = \{'C': (array({[}-8.65e-05,  1.18e-05,  7.47e-05{]}), 0.6632251157578453), 'H': (array({[}-5.8e-06,  0.0e+00,  5.8e-06{]}), 0.13962634015954636), 'N': (array({[}-6.280e-05, -4.570e-05,  1.085e-04{]}), 0.33161255787892263)\}}}}
docstring for CustomAtom

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.gyro\_lib}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.gyro_lib:paramagpy-protein-customatom-gyro-lib}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.gyro_lib::doc}}\index{gyro\_lib (paramagpy.protein.CustomAtom attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.gyro_lib:paramagpy.protein.CustomAtom.gyro_lib}}\pysigline{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{gyro\_lib}}\sphinxbfcode{\sphinxupquote{ = \{'C': 67261498.71335746, 'H': 267512897.63847807, 'N': -27118227.785787094\}}}}
\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.position}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.position:paramagpy-protein-customatom-position}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.position::doc}}\index{position (paramagpy.protein.CustomAtom attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.position:paramagpy.protein.CustomAtom.position}}\pysigline{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{position}}}
\end{fulllineitems}


\end{fulllineitems}


\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure:paramagpy-protein-customstructure}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure::doc}}\index{CustomStructure (class in paramagpy.protein)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure:paramagpy.protein.CustomStructure}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{paramagpy.protein.}}\sphinxbfcode{\sphinxupquote{CustomStructure}}}{\emph{*arg}, \emph{**kwargs}}{}
This is an overload hack of the BioPython Structure object
\index{\_\_init\_\_() (paramagpy.protein.CustomStructure method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure:paramagpy.protein.CustomStructure.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{*arg}, \emph{**kwargs}}{}
Initialize the class.
\subsubsection*{Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.add:paramagpy.protein.CustomStructure.add}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{add}}}}}(entity)
&
Add a child to the Entity.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.copy:paramagpy.protein.CustomStructure.copy}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{copy}}}}}()
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.detach_child:paramagpy.protein.CustomStructure.detach_child}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{detach\_child}}}}}(id)
&
Remove a child.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.detach_parent:paramagpy.protein.CustomStructure.detach_parent}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{detach\_parent}}}}}()
&
Detach the parent.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_atoms:paramagpy.protein.CustomStructure.get_atoms}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_atoms}}}}}()
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_chains:paramagpy.protein.CustomStructure.get_chains}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_chains}}}}}()
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_full_id:paramagpy.protein.CustomStructure.get_full_id}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_full\_id}}}}}()
&
Return the full id.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_id:paramagpy.protein.CustomStructure.get_id}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_id}}}}}()
&
Return the id.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_iterator:paramagpy.protein.CustomStructure.get_iterator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_iterator}}}}}()
&
Return iterator over children.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_level:paramagpy.protein.CustomStructure.get_level}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_level}}}}}()
&
Return level in hierarchy.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_list:paramagpy.protein.CustomStructure.get_list}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_list}}}}}()
&
Return a copy of the list of children.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_models:paramagpy.protein.CustomStructure.get_models}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_models}}}}}()
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_parent:paramagpy.protein.CustomStructure.get_parent}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_parent}}}}}()
&
Return the parent Entity object.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_residues:paramagpy.protein.CustomStructure.get_residues}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_residues}}}}}()
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.has_id:paramagpy.protein.CustomStructure.has_id}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{has\_id}}}}}(id)
&
Check if a child with given id exists.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.insert:paramagpy.protein.CustomStructure.insert}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{insert}}}}}(pos, entity)
&
Add a child to the Entity at a specified position.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.parse:paramagpy.protein.CustomStructure.parse}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{parse}}}}}(dataValues{[}, models{]})
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.set_parent:paramagpy.protein.CustomStructure.set_parent}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_parent}}}}}(entity)
&
Set the parent Entity object.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.transform:paramagpy.protein.CustomStructure.transform}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{transform}}}}}(rot, tran)
&
Apply rotation and translation to the atomic coordinates.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{paramagpy.protein.CustomStructure.add}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.add:paramagpy-protein-customstructure-add}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.add::doc}}\index{add() (paramagpy.protein.CustomStructure method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.add:paramagpy.protein.CustomStructure.add}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{add}}}{\emph{entity}}{}
Add a child to the Entity.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.copy}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.copy:paramagpy-protein-customstructure-copy}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.copy::doc}}\index{copy() (paramagpy.protein.CustomStructure method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.copy:paramagpy.protein.CustomStructure.copy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{copy}}}{}{}
\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.detach\_child}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.detach_child:paramagpy-protein-customstructure-detach-child}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.detach_child::doc}}\index{detach\_child() (paramagpy.protein.CustomStructure method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.detach_child:paramagpy.protein.CustomStructure.detach_child}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{detach\_child}}}{\emph{id}}{}
Remove a child.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.detach\_parent}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.detach_parent:paramagpy-protein-customstructure-detach-parent}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.detach_parent::doc}}\index{detach\_parent() (paramagpy.protein.CustomStructure method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.detach_parent:paramagpy.protein.CustomStructure.detach_parent}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{detach\_parent}}}{}{}
Detach the parent.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.get\_atoms}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_atoms:paramagpy-protein-customstructure-get-atoms}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_atoms::doc}}\index{get\_atoms() (paramagpy.protein.CustomStructure method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_atoms:paramagpy.protein.CustomStructure.get_atoms}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{get\_atoms}}}{}{}
\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.get\_chains}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_chains:paramagpy-protein-customstructure-get-chains}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_chains::doc}}\index{get\_chains() (paramagpy.protein.CustomStructure method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_chains:paramagpy.protein.CustomStructure.get_chains}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{get\_chains}}}{}{}
\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.get\_full\_id}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_full_id:paramagpy-protein-customstructure-get-full-id}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_full_id::doc}}\index{get\_full\_id() (paramagpy.protein.CustomStructure method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_full_id:paramagpy.protein.CustomStructure.get_full_id}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{get\_full\_id}}}{}{}
Return the full id.

The full id is a tuple containing all id’s starting from
the top object (Structure) down to the current object. A full id for
a Residue object e.g. is something like:

(“1abc”, 0, “A”, (” “, 10, “A”))

This corresponds to:

Structure with id “1abc”
Model with id 0
Chain with id “A”
Residue with id (” “, 10, “A”)

The Residue id indicates that the residue is not a hetero-residue
(or a water) because it has a blank hetero field, that its sequence
identifier is 10 and its insertion code “A”.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.get\_id}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_id:paramagpy-protein-customstructure-get-id}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_id::doc}}\index{get\_id() (paramagpy.protein.CustomStructure method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_id:paramagpy.protein.CustomStructure.get_id}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{get\_id}}}{}{}
Return the id.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.get\_iterator}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_iterator:paramagpy-protein-customstructure-get-iterator}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_iterator::doc}}\index{get\_iterator() (paramagpy.protein.CustomStructure method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_iterator:paramagpy.protein.CustomStructure.get_iterator}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{get\_iterator}}}{}{}
Return iterator over children.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.get\_level}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_level:paramagpy-protein-customstructure-get-level}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_level::doc}}\index{get\_level() (paramagpy.protein.CustomStructure method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_level:paramagpy.protein.CustomStructure.get_level}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{get\_level}}}{}{}
Return level in hierarchy.

A - atom
R - residue
C - chain
M - model
S - structure

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.get\_list}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_list:paramagpy-protein-customstructure-get-list}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_list::doc}}\index{get\_list() (paramagpy.protein.CustomStructure method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_list:paramagpy.protein.CustomStructure.get_list}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{get\_list}}}{}{}
Return a copy of the list of children.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.get\_models}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_models:paramagpy-protein-customstructure-get-models}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_models::doc}}\index{get\_models() (paramagpy.protein.CustomStructure method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_models:paramagpy.protein.CustomStructure.get_models}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{get\_models}}}{}{}
\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.get\_parent}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_parent:paramagpy-protein-customstructure-get-parent}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_parent::doc}}\index{get\_parent() (paramagpy.protein.CustomStructure method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_parent:paramagpy.protein.CustomStructure.get_parent}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{get\_parent}}}{}{}
Return the parent Entity object.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.get\_residues}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_residues:paramagpy-protein-customstructure-get-residues}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_residues::doc}}\index{get\_residues() (paramagpy.protein.CustomStructure method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_residues:paramagpy.protein.CustomStructure.get_residues}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{get\_residues}}}{}{}
\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.has\_id}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.has_id:paramagpy-protein-customstructure-has-id}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.has_id::doc}}\index{has\_id() (paramagpy.protein.CustomStructure method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.has_id:paramagpy.protein.CustomStructure.has_id}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{has\_id}}}{\emph{id}}{}
Check if a child with given id exists.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.insert}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.insert:paramagpy-protein-customstructure-insert}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.insert::doc}}\index{insert() (paramagpy.protein.CustomStructure method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.insert:paramagpy.protein.CustomStructure.insert}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{insert}}}{\emph{pos}, \emph{entity}}{}
Add a child to the Entity at a specified position.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.parse}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.parse:paramagpy-protein-customstructure-parse}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.parse::doc}}\index{parse() (paramagpy.protein.CustomStructure method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.parse:paramagpy.protein.CustomStructure.parse}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{parse}}}{\emph{dataValues}, \emph{models=None}}{}
\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.set\_parent}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.set_parent:paramagpy-protein-customstructure-set-parent}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.set_parent::doc}}\index{set\_parent() (paramagpy.protein.CustomStructure method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.set_parent:paramagpy.protein.CustomStructure.set_parent}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{set\_parent}}}{\emph{entity}}{}
Set the parent Entity object.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.transform}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.transform:paramagpy-protein-customstructure-transform}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.transform::doc}}\index{transform() (paramagpy.protein.CustomStructure method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.transform:paramagpy.protein.CustomStructure.transform}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{transform}}}{\emph{rot}, \emph{tran}}{}
Apply rotation and translation to the atomic coordinates.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rot}} (\sphinxstyleliteralemphasis{\sphinxupquote{3x3 Numeric array}}) \textendash{} A right multiplying rotation matrix

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tran}} (\sphinxstyleliteralemphasis{\sphinxupquote{size 3 Numeric array}}) \textendash{} the translation vector

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Examples}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rotation} \PYG{o}{=} \PYG{n}{rotmat}\PYG{p}{(}\PYG{n}{pi}\PYG{p}{,} \PYG{n}{Vector}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{translation} \PYG{o}{=} \PYG{n}{array}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{entity}\PYG{o}{.}\PYG{n}{transform}\PYG{p}{(}\PYG{n}{rotation}\PYG{p}{,} \PYG{n}{translation}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\subsubsection*{Attributes}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.id:paramagpy.protein.CustomStructure.id}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{id}}}}}
&

\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{paramagpy.protein.CustomStructure.id}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.id:paramagpy-protein-customstructure-id}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.id::doc}}\index{id (paramagpy.protein.CustomStructure attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.id:paramagpy.protein.CustomStructure.id}}\pysigline{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{id}}}
\end{fulllineitems}


\end{fulllineitems}


\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructureBuilder}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder:paramagpy-protein-customstructurebuilder}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder::doc}}\index{CustomStructureBuilder (class in paramagpy.protein)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder:paramagpy.protein.CustomStructureBuilder}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{paramagpy.protein.}}\sphinxbfcode{\sphinxupquote{CustomStructureBuilder}}}{\emph{*arg}, \emph{**kwargs}}{}
This is an overload hack of BioPython’s CustomStructureBuilder
\index{\_\_init\_\_() (paramagpy.protein.CustomStructureBuilder method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder:paramagpy.protein.CustomStructureBuilder.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{*arg}, \emph{**kwargs}}{}
Initialize the class.
\subsubsection*{Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.get_structure:paramagpy.protein.CustomStructureBuilder.get_structure}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_structure}}}}}()
&
Return the structure.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_atom:paramagpy.protein.CustomStructureBuilder.init_atom}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{init\_atom}}}}}(name, coord, b\_factor, occupancy, …)
&
Create a new Atom object.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_chain:paramagpy.protein.CustomStructureBuilder.init_chain}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{init\_chain}}}}}(chain\_id)
&
Create a new Chain object with given id.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_model:paramagpy.protein.CustomStructureBuilder.init_model}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{init\_model}}}}}(model\_id{[}, serial\_num{]})
&
Create a new Model object with given id.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_residue:paramagpy.protein.CustomStructureBuilder.init_residue}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{init\_residue}}}}}(resname, field, resseq, icode)
&
Create a new Residue object.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_seg:paramagpy.protein.CustomStructureBuilder.init_seg}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{init\_seg}}}}}(segid)
&
Flag a change in segid.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_structure:paramagpy.protein.CustomStructureBuilder.init_structure}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{init\_structure}}}}}(structure\_id)
&
Initialize a new Structure object with given id.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_anisou:paramagpy.protein.CustomStructureBuilder.set_anisou}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_anisou}}}}}(anisou\_array)
&
Set anisotropic B factor of current Atom.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_header:paramagpy.protein.CustomStructureBuilder.set_header}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_header}}}}}(header)
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_line_counter:paramagpy.protein.CustomStructureBuilder.set_line_counter}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_line\_counter}}}}}(line\_counter)
&
Tracks line in the PDB file that is being parsed.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_sigatm:paramagpy.protein.CustomStructureBuilder.set_sigatm}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_sigatm}}}}}(sigatm\_array)
&
Set standard deviation of atom position of current Atom.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_siguij:paramagpy.protein.CustomStructureBuilder.set_siguij}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_siguij}}}}}(siguij\_array)
&
Set standard deviation of anisotropic B factor of current Atom.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_symmetry:paramagpy.protein.CustomStructureBuilder.set_symmetry}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_symmetry}}}}}(spacegroup, cell)
&

\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{paramagpy.protein.CustomStructureBuilder.get\_structure}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.get_structure:paramagpy-protein-customstructurebuilder-get-structure}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.get_structure::doc}}\index{get\_structure() (paramagpy.protein.CustomStructureBuilder method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.get_structure:paramagpy.protein.CustomStructureBuilder.get_structure}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructureBuilder.}}\sphinxbfcode{\sphinxupquote{get\_structure}}}{}{}
Return the structure.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructureBuilder.init\_atom}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_atom:paramagpy-protein-customstructurebuilder-init-atom}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_atom::doc}}\index{init\_atom() (paramagpy.protein.CustomStructureBuilder method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_atom:paramagpy.protein.CustomStructureBuilder.init_atom}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructureBuilder.}}\sphinxbfcode{\sphinxupquote{init\_atom}}}{\emph{name}, \emph{coord}, \emph{b\_factor}, \emph{occupancy}, \emph{altloc}, \emph{fullname}, \emph{serial\_number=None}, \emph{element=None}}{}
Create a new Atom object.
:param - name - string, atom name, e.g. CA, spaces should be stripped:
:param - coord - Numeric array:
:type - coord - Numeric array: Float0, size 3
:param - b\_factor - float, B factor:
:param - occupancy - float:
:param - altloc - string, alternative location specifier:
:param - fullname - string, atom name including spaces, e.g. ” CA “:
:param - element - string, upper case, e.g. “HG” for mercury:

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructureBuilder.init\_chain}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_chain:paramagpy-protein-customstructurebuilder-init-chain}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_chain::doc}}\index{init\_chain() (paramagpy.protein.CustomStructureBuilder method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_chain:paramagpy.protein.CustomStructureBuilder.init_chain}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructureBuilder.}}\sphinxbfcode{\sphinxupquote{init\_chain}}}{\emph{chain\_id}}{}
Create a new Chain object with given id.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{chain\_id - string}} (\sphinxstyleliteralemphasis{\sphinxupquote{-}}) \textendash{} 

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructureBuilder.init\_model}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_model:paramagpy-protein-customstructurebuilder-init-model}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_model::doc}}\index{init\_model() (paramagpy.protein.CustomStructureBuilder method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_model:paramagpy.protein.CustomStructureBuilder.init_model}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructureBuilder.}}\sphinxbfcode{\sphinxupquote{init\_model}}}{\emph{model\_id}, \emph{serial\_num=None}}{}
Create a new Model object with given id.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{id - int}} (\sphinxstyleliteralemphasis{\sphinxupquote{-}}) \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{serial\_num - int}} (\sphinxstyleliteralemphasis{\sphinxupquote{-}}) \textendash{} 

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructureBuilder.init\_residue}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_residue:paramagpy-protein-customstructurebuilder-init-residue}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_residue::doc}}\index{init\_residue() (paramagpy.protein.CustomStructureBuilder method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_residue:paramagpy.protein.CustomStructureBuilder.init_residue}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructureBuilder.}}\sphinxbfcode{\sphinxupquote{init\_residue}}}{\emph{resname}, \emph{field}, \emph{resseq}, \emph{icode}}{}
Create a new Residue object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{resname - string}}\sphinxstyleliteralstrong{\sphinxupquote{, }}\sphinxstyleliteralstrong{\sphinxupquote{e.g. "ASN"}} (\sphinxstyleliteralemphasis{\sphinxupquote{-}}) \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{field - hetero flag}}\sphinxstyleliteralstrong{\sphinxupquote{, }}\sphinxstyleliteralstrong{\sphinxupquote{"W" for waters}}\sphinxstyleliteralstrong{\sphinxupquote{, }}\sphinxstyleliteralstrong{\sphinxupquote{"H" for}} (\sphinxstyleliteralemphasis{\sphinxupquote{-}}) \textendash{} hetero residues, otherwise blank.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{resseq - int}}\sphinxstyleliteralstrong{\sphinxupquote{, }}\sphinxstyleliteralstrong{\sphinxupquote{sequence identifier}} (\sphinxstyleliteralemphasis{\sphinxupquote{-}}) \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{icode - string}}\sphinxstyleliteralstrong{\sphinxupquote{, }}\sphinxstyleliteralstrong{\sphinxupquote{insertion code}} (\sphinxstyleliteralemphasis{\sphinxupquote{-}}) \textendash{} 

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructureBuilder.init\_seg}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_seg:paramagpy-protein-customstructurebuilder-init-seg}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_seg::doc}}\index{init\_seg() (paramagpy.protein.CustomStructureBuilder method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_seg:paramagpy.protein.CustomStructureBuilder.init_seg}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructureBuilder.}}\sphinxbfcode{\sphinxupquote{init\_seg}}}{\emph{segid}}{}
Flag a change in segid.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{segid - string}} (\sphinxstyleliteralemphasis{\sphinxupquote{-}}) \textendash{} 

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructureBuilder.init\_structure}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_structure:paramagpy-protein-customstructurebuilder-init-structure}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_structure::doc}}\index{init\_structure() (paramagpy.protein.CustomStructureBuilder method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_structure:paramagpy.protein.CustomStructureBuilder.init_structure}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructureBuilder.}}\sphinxbfcode{\sphinxupquote{init\_structure}}}{\emph{structure\_id}}{}
Initialize a new Structure object with given id.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{id - string}} (\sphinxstyleliteralemphasis{\sphinxupquote{-}}) \textendash{} 

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructureBuilder.set\_anisou}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_anisou:paramagpy-protein-customstructurebuilder-set-anisou}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_anisou::doc}}\index{set\_anisou() (paramagpy.protein.CustomStructureBuilder method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_anisou:paramagpy.protein.CustomStructureBuilder.set_anisou}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructureBuilder.}}\sphinxbfcode{\sphinxupquote{set\_anisou}}}{\emph{anisou\_array}}{}
Set anisotropic B factor of current Atom.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructureBuilder.set\_header}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_header:paramagpy-protein-customstructurebuilder-set-header}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_header::doc}}\index{set\_header() (paramagpy.protein.CustomStructureBuilder method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_header:paramagpy.protein.CustomStructureBuilder.set_header}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructureBuilder.}}\sphinxbfcode{\sphinxupquote{set\_header}}}{\emph{header}}{}
\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructureBuilder.set\_line\_counter}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_line_counter:paramagpy-protein-customstructurebuilder-set-line-counter}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_line_counter::doc}}\index{set\_line\_counter() (paramagpy.protein.CustomStructureBuilder method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_line_counter:paramagpy.protein.CustomStructureBuilder.set_line_counter}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructureBuilder.}}\sphinxbfcode{\sphinxupquote{set\_line\_counter}}}{\emph{line\_counter}}{}
Tracks line in the PDB file that is being parsed.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{line\_counter - int}} (\sphinxstyleliteralemphasis{\sphinxupquote{-}}) \textendash{} 

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructureBuilder.set\_sigatm}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_sigatm:paramagpy-protein-customstructurebuilder-set-sigatm}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_sigatm::doc}}\index{set\_sigatm() (paramagpy.protein.CustomStructureBuilder method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_sigatm:paramagpy.protein.CustomStructureBuilder.set_sigatm}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructureBuilder.}}\sphinxbfcode{\sphinxupquote{set\_sigatm}}}{\emph{sigatm\_array}}{}
Set standard deviation of atom position of current Atom.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructureBuilder.set\_siguij}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_siguij:paramagpy-protein-customstructurebuilder-set-siguij}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_siguij::doc}}\index{set\_siguij() (paramagpy.protein.CustomStructureBuilder method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_siguij:paramagpy.protein.CustomStructureBuilder.set_siguij}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructureBuilder.}}\sphinxbfcode{\sphinxupquote{set\_siguij}}}{\emph{siguij\_array}}{}
Set standard deviation of anisotropic B factor of current Atom.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructureBuilder.set\_symmetry}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_symmetry:paramagpy-protein-customstructurebuilder-set-symmetry}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_symmetry::doc}}\index{set\_symmetry() (paramagpy.protein.CustomStructureBuilder method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_symmetry:paramagpy.protein.CustomStructureBuilder.set_symmetry}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructureBuilder.}}\sphinxbfcode{\sphinxupquote{set\_symmetry}}}{\emph{spacegroup}, \emph{cell}}{}
\end{fulllineitems}


\end{fulllineitems}


\end{fulllineitems}



\subsection{Data I/O module}
\label{\detokenize{reference/index:data-i-o-module}}
This module handles the reading and writing of experimental data.


\subsubsection{paramagpy.dataparse}
\label{\detokenize{reference/dataparse:module-paramagpy.dataparse}}\label{\detokenize{reference/dataparse:paramagpy-dataparse}}\label{\detokenize{reference/dataparse:dataparse}}\label{\detokenize{reference/dataparse::doc}}\index{paramagpy.dataparse (module)}

\paragraph{Functions}
\label{\detokenize{reference/dataparse:functions}}

\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.read_pcs:paramagpy.dataparse.read_pcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{read\_pcs}}}}}(fileName)
&
Read pseudo contact shift values from file.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.read_rdc:paramagpy.dataparse.read_rdc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{read\_rdc}}}}}(fileName)
&
Read residual dipolar coupling values from file.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.read_pre:paramagpy.dataparse.read_pre}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{read\_pre}}}}}(fileName)
&
Read paramagnetic relaxation enhancement values from file.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.read_ccr:paramagpy.dataparse.read_ccr}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{read\_ccr}}}}}(fileName)
&
Read cross-correlated relaxation values from file.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{paramagpy.dataparse.read\_pcs}
\label{\detokenize{reference/generated/paramagpy.dataparse.read_pcs:paramagpy-dataparse-read-pcs}}\label{\detokenize{reference/generated/paramagpy.dataparse.read_pcs::doc}}\index{read\_pcs() (in module paramagpy.dataparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.dataparse.read_pcs:paramagpy.dataparse.read_pcs}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.dataparse.}}\sphinxbfcode{\sphinxupquote{read\_pcs}}}{\emph{fileName}}{}
Read pseudo contact shift values from file.
The returned object is a dicationary.
They keys are tuples of (sequence, atomName)
The values are tuples of (value, error)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{fileName}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} the path to the file

\item[{Returns}] \leavevmode
\sphinxstylestrong{values} \textendash{} a dictionary containing the parsed data

\item[{Return type}] \leavevmode
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.DataContainer:paramagpy.dataparse.DataContainer}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.dataparse.DataContainer}}}}}

\end{description}\end{quote}
\subsubsection*{Examples}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{values} \PYG{o}{=} \PYG{n}{paramagpy}\PYG{o}{.}\PYG{n}{dataparse}\PYG{o}{.}\PYG{n}{read\PYGZus{}pcs}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{calbindin\PYGZus{}Er\PYGZus{}HN\PYGZus{}PCS\PYGZus{}errors.npc}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{values}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+go}{((2, \PYGZsq{}H\PYGZsq{}), (\PYGZhy{}0.04855485, 0.0016))}
\PYG{g+go}{((2, \PYGZsq{}N\PYGZsq{}), (\PYGZhy{}0.03402764, 0.0009))}
\PYG{g+go}{((4, \PYGZsq{}H\PYGZsq{}), (\PYGZhy{}0.18470315, 0.0004))}
\PYG{g+gp}{...}
\PYG{g+go}{((75, \PYGZsq{}H\PYGZsq{}), (0.19553661, 0.0005))}
\PYG{g+go}{((75, \PYGZsq{}N\PYGZsq{}), (0.17840666, 0.0004))}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{paramagpy.dataparse.read\_rdc}
\label{\detokenize{reference/generated/paramagpy.dataparse.read_rdc:paramagpy-dataparse-read-rdc}}\label{\detokenize{reference/generated/paramagpy.dataparse.read_rdc::doc}}\index{read\_rdc() (in module paramagpy.dataparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.dataparse.read_rdc:paramagpy.dataparse.read_rdc}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.dataparse.}}\sphinxbfcode{\sphinxupquote{read\_rdc}}}{\emph{fileName}}{}
Read residual dipolar coupling values from file.
The returned object is a dicationary.
They keys are frozensets of tuples of the form:
frozenset(\{(sequence1, atomName1), (sequence2, atomName2)\})
The frozenset only allows unordered unique atom identification pairs
The values are tuples of (value, error)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{fileName}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} the path to the file

\item[{Returns}] \leavevmode
\sphinxstylestrong{values} \textendash{} a dictionary containing the parsed data

\item[{Return type}] \leavevmode
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.DataContainer:paramagpy.dataparse.DataContainer}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.dataparse.DataContainer}}}}}

\end{description}\end{quote}
\subsubsection*{Examples}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{values} \PYG{o}{=} \PYG{n}{paramagpy}\PYG{o}{.}\PYG{n}{dataparse}\PYG{o}{.}\PYG{n}{read\PYGZus{}rdc}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ubiquitin\PYGZus{}a28c\PYGZus{}c1\PYGZus{}Tb\PYGZus{}HN.rdc}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{values}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+go}{(frozenset(\PYGZob{}(2, \PYGZsq{}N\PYGZsq{}), (2, \PYGZsq{}H\PYGZsq{})\PYGZcb{}), (\PYGZhy{}2.35, 0.32))}
\PYG{g+go}{(frozenset(\PYGZob{}(3, \PYGZsq{}N\PYGZsq{}), (3, \PYGZsq{}H\PYGZsq{})\PYGZcb{}), (\PYGZhy{}4.05, 0.38))}
\PYG{g+go}{(frozenset(\PYGZob{}(4, \PYGZsq{}H\PYGZsq{}), (4, \PYGZsq{}N\PYGZsq{})\PYGZcb{}), (\PYGZhy{}3.58, 0.42))}
\PYG{g+gp}{...}
\PYG{g+go}{(frozenset(\PYGZob{}(73, \PYGZsq{}N\PYGZsq{}), (73, \PYGZsq{}H\PYGZsq{})\PYGZcb{}), (\PYGZhy{}0.47, 0.75))}
\PYG{g+go}{(frozenset(\PYGZob{}(76, \PYGZsq{}H\PYGZsq{}), (76, \PYGZsq{}N\PYGZsq{})\PYGZcb{}), (0.14, 0.3))}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{paramagpy.dataparse.read\_pre}
\label{\detokenize{reference/generated/paramagpy.dataparse.read_pre:paramagpy-dataparse-read-pre}}\label{\detokenize{reference/generated/paramagpy.dataparse.read_pre::doc}}\index{read\_pre() (in module paramagpy.dataparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.dataparse.read_pre:paramagpy.dataparse.read_pre}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.dataparse.}}\sphinxbfcode{\sphinxupquote{read\_pre}}}{\emph{fileName}}{}
Read paramagnetic relaxation enhancement values from file.
The returned object is a dicationary.
They keys are tuples of (sequence, atomName)
The values are tuples of (value, error)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{fileName}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} the path to the file

\item[{Returns}] \leavevmode
\sphinxstylestrong{values} \textendash{} a dictionary containing the parsed data

\item[{Return type}] \leavevmode
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.DataContainer:paramagpy.dataparse.DataContainer}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.dataparse.DataContainer}}}}}

\end{description}\end{quote}
\subsubsection*{Examples}

see {\hyperref[\detokenize{reference/generated/paramagpy.dataparse.read_pcs:paramagpy.dataparse.read_pcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.dataparse.read\_pcs()}}}}} which has the same file structure

\end{fulllineitems}



\subparagraph{paramagpy.dataparse.read\_ccr}
\label{\detokenize{reference/generated/paramagpy.dataparse.read_ccr:paramagpy-dataparse-read-ccr}}\label{\detokenize{reference/generated/paramagpy.dataparse.read_ccr::doc}}\index{read\_ccr() (in module paramagpy.dataparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.dataparse.read_ccr:paramagpy.dataparse.read_ccr}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.dataparse.}}\sphinxbfcode{\sphinxupquote{read\_ccr}}}{\emph{fileName}}{}
Read cross-correlated relaxation values from file.
These are typically Curie-spin cross Dipole-dipole relaxation rates
The returned object is a dicationary.
They keys are tuples of the form:
((sequence1, atomName1), (sequence2, atomName2))
Note that the first column is for the active nucleus undergoing
relaxation and the second column is for the partner spin.
The values are tuples of (value, error)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{fileName}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} the path to the file

\item[{Returns}] \leavevmode
\sphinxstylestrong{values} \textendash{} a dictionary containing the parsed data

\item[{Return type}] \leavevmode
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.DataContainer:paramagpy.dataparse.DataContainer}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.dataparse.DataContainer}}}}}

\end{description}\end{quote}
\subsubsection*{Examples}

see {\hyperref[\detokenize{reference/generated/paramagpy.dataparse.read_rdc:paramagpy.dataparse.read_rdc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.dataparse.read\_rdc()}}}}} which has the similar file structure

\end{fulllineitems}



\paragraph{Classes}
\label{\detokenize{reference/dataparse:classes}}

\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.DataContainer:paramagpy.dataparse.DataContainer}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DataContainer}}}}}(*args, **kwargs)
&
A dictionary-like container for storing PCS, RDC, PRE and CCR data Has an additional attribute ‘dtype’ to define datatype
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{paramagpy.dataparse.DataContainer}
\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer:paramagpy-dataparse-datacontainer}}\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer::doc}}\index{DataContainer (class in paramagpy.dataparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer:paramagpy.dataparse.DataContainer}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{paramagpy.dataparse.}}\sphinxbfcode{\sphinxupquote{DataContainer}}}{\emph{*args}, \emph{**kwargs}}{}
A dictionary-like container for storing
PCS, RDC, PRE and CCR data
Has an additional attribute ‘dtype’ to define datatype
\index{\_\_init\_\_() (paramagpy.dataparse.DataContainer method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer:paramagpy.dataparse.DataContainer.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{*args}, \emph{**kwargs}}{}
Initialize self.  See help(type(self)) for accurate signature.
\subsubsection*{Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.DataContainer.clear:paramagpy.dataparse.DataContainer.clear}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{clear}}}}}()
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.DataContainer.copy:paramagpy.dataparse.DataContainer.copy}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{copy}}}}}()
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.DataContainer.fromkeys:paramagpy.dataparse.DataContainer.fromkeys}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fromkeys}}}}}(S{[}, v{]})
&
If not specified, the value defaults to None.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.DataContainer.get:paramagpy.dataparse.DataContainer.get}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get}}}}}(k{[},d{]})
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.DataContainer.items:paramagpy.dataparse.DataContainer.items}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{items}}}}}()
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.DataContainer.keys:paramagpy.dataparse.DataContainer.keys}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{keys}}}}}()
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.DataContainer.move_to_end:paramagpy.dataparse.DataContainer.move_to_end}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{move\_to\_end}}}}}
&
Move an existing element to the end (or beginning if last==False).
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.DataContainer.pop:paramagpy.dataparse.DataContainer.pop}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pop}}}}}(k{[},d{]})
&
value.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.DataContainer.popitem:paramagpy.dataparse.DataContainer.popitem}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{popitem}}}}}()
&
Pairs are returned in LIFO order if last is true or FIFO order if false.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.DataContainer.setdefault:paramagpy.dataparse.DataContainer.setdefault}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{setdefault}}}}}(k{[},d{]})
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.DataContainer.update:paramagpy.dataparse.DataContainer.update}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{update}}}}}({[}E, {]}**F)
&
If E is present and has a .keys() method, then does:  for k in E: D{[}k{]} = E{[}k{]} If E is present and lacks a .keys() method, then does:  for k, v in E: D{[}k{]} = v In either case, this is followed by: for k in F:  D{[}k{]} = F{[}k{]}
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.DataContainer.values:paramagpy.dataparse.DataContainer.values}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{values}}}}}()
&

\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{paramagpy.dataparse.DataContainer.clear}
\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.clear:paramagpy-dataparse-datacontainer-clear}}\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.clear::doc}}\index{clear() (paramagpy.dataparse.DataContainer method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.clear:paramagpy.dataparse.DataContainer.clear}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DataContainer.}}\sphinxbfcode{\sphinxupquote{clear}}}{}{{ $\rightarrow$ None.  Remove all items from od.}}
\end{fulllineitems}



\subparagraph{paramagpy.dataparse.DataContainer.copy}
\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.copy:paramagpy-dataparse-datacontainer-copy}}\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.copy::doc}}\index{copy() (paramagpy.dataparse.DataContainer method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.copy:paramagpy.dataparse.DataContainer.copy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DataContainer.}}\sphinxbfcode{\sphinxupquote{copy}}}{}{{ $\rightarrow$ a shallow copy of od}}
\end{fulllineitems}



\subparagraph{paramagpy.dataparse.DataContainer.fromkeys}
\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.fromkeys:paramagpy-dataparse-datacontainer-fromkeys}}\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.fromkeys::doc}}\index{fromkeys() (paramagpy.dataparse.DataContainer method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.fromkeys:paramagpy.dataparse.DataContainer.fromkeys}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DataContainer.}}\sphinxbfcode{\sphinxupquote{fromkeys}}}{\emph{S}\sphinxoptional{, \emph{v}}}{{ $\rightarrow$ New ordered dictionary with keys from S.}}
If not specified, the value defaults to None.

\end{fulllineitems}



\subparagraph{paramagpy.dataparse.DataContainer.get}
\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.get:paramagpy-dataparse-datacontainer-get}}\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.get::doc}}\index{get() (paramagpy.dataparse.DataContainer method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.get:paramagpy.dataparse.DataContainer.get}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DataContainer.}}\sphinxbfcode{\sphinxupquote{get}}}{\emph{k}\sphinxoptional{, \emph{d}}}{{ $\rightarrow$ D{[}k{]} if k in D, else d.  d defaults to None.}}
\end{fulllineitems}



\subparagraph{paramagpy.dataparse.DataContainer.items}
\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.items:paramagpy-dataparse-datacontainer-items}}\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.items::doc}}\index{items() (paramagpy.dataparse.DataContainer method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.items:paramagpy.dataparse.DataContainer.items}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DataContainer.}}\sphinxbfcode{\sphinxupquote{items}}}{}{{ $\rightarrow$ a set-like object providing a view on D's items}}
\end{fulllineitems}



\subparagraph{paramagpy.dataparse.DataContainer.keys}
\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.keys:paramagpy-dataparse-datacontainer-keys}}\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.keys::doc}}\index{keys() (paramagpy.dataparse.DataContainer method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.keys:paramagpy.dataparse.DataContainer.keys}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DataContainer.}}\sphinxbfcode{\sphinxupquote{keys}}}{}{{ $\rightarrow$ a set-like object providing a view on D's keys}}
\end{fulllineitems}



\subparagraph{paramagpy.dataparse.DataContainer.move\_to\_end}
\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.move_to_end:paramagpy-dataparse-datacontainer-move-to-end}}\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.move_to_end::doc}}\index{move\_to\_end() (paramagpy.dataparse.DataContainer method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.move_to_end:paramagpy.dataparse.DataContainer.move_to_end}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DataContainer.}}\sphinxbfcode{\sphinxupquote{move\_to\_end}}}{}{}
Move an existing element to the end (or beginning if last==False).

Raises KeyError if the element does not exist.
When last=True, acts like a fast version of self{[}key{]}=self.pop(key).

\end{fulllineitems}



\subparagraph{paramagpy.dataparse.DataContainer.pop}
\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.pop:paramagpy-dataparse-datacontainer-pop}}\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.pop::doc}}\index{pop() (paramagpy.dataparse.DataContainer method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.pop:paramagpy.dataparse.DataContainer.pop}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DataContainer.}}\sphinxbfcode{\sphinxupquote{pop}}}{\emph{k}\sphinxoptional{, \emph{d}}}{{ $\rightarrow$ v, remove specified key and return the corresponding}}
value.  If key is not found, d is returned if given, otherwise KeyError
is raised.

\end{fulllineitems}



\subparagraph{paramagpy.dataparse.DataContainer.popitem}
\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.popitem:paramagpy-dataparse-datacontainer-popitem}}\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.popitem::doc}}\index{popitem() (paramagpy.dataparse.DataContainer method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.popitem:paramagpy.dataparse.DataContainer.popitem}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DataContainer.}}\sphinxbfcode{\sphinxupquote{popitem}}}{}{{ $\rightarrow$ (k, v), return and remove a (key, value) pair.}}
Pairs are returned in LIFO order if last is true or FIFO order if false.

\end{fulllineitems}



\subparagraph{paramagpy.dataparse.DataContainer.setdefault}
\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.setdefault:paramagpy-dataparse-datacontainer-setdefault}}\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.setdefault::doc}}\index{setdefault() (paramagpy.dataparse.DataContainer method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.setdefault:paramagpy.dataparse.DataContainer.setdefault}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DataContainer.}}\sphinxbfcode{\sphinxupquote{setdefault}}}{\emph{k}\sphinxoptional{, \emph{d}}}{{ $\rightarrow$ od.get(k,d), also set od{[}k{]}=d if k not in od}}
\end{fulllineitems}



\subparagraph{paramagpy.dataparse.DataContainer.update}
\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.update:paramagpy-dataparse-datacontainer-update}}\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.update::doc}}\index{update() (paramagpy.dataparse.DataContainer method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.update:paramagpy.dataparse.DataContainer.update}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DataContainer.}}\sphinxbfcode{\sphinxupquote{update}}}{\sphinxoptional{\emph{E}}, \emph{**F}}{{ $\rightarrow$ None.  Update D from dict/iterable E and F.}}
If E is present and has a .keys() method, then does:  for k in E: D{[}k{]} = E{[}k{]}
If E is present and lacks a .keys() method, then does:  for k, v in E: D{[}k{]} = v
In either case, this is followed by: for k in F:  D{[}k{]} = F{[}k{]}

\end{fulllineitems}



\subparagraph{paramagpy.dataparse.DataContainer.values}
\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.values:paramagpy-dataparse-datacontainer-values}}\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.values::doc}}\index{values() (paramagpy.dataparse.DataContainer method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.values:paramagpy.dataparse.DataContainer.values}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DataContainer.}}\sphinxbfcode{\sphinxupquote{values}}}{}{{ $\rightarrow$ an object providing a view on D's values}}
\end{fulllineitems}


\end{fulllineitems}


\end{fulllineitems}



\subsection{Fitting module}
\label{\detokenize{reference/index:fitting-module}}
This module handles the fitting of paramagnetic objects to experimental data.


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{reference/generated/paramagpy.fit:module-paramagpy.fit}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.fit}}}}}
&

\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subsubsection{paramagpy.fit}
\label{\detokenize{reference/generated/paramagpy.fit:module-paramagpy.fit}}\label{\detokenize{reference/generated/paramagpy.fit:paramagpy-fit}}\label{\detokenize{reference/generated/paramagpy.fit::doc}}\index{paramagpy.fit (module)}\subsubsection*{Functions}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{reference/generated/paramagpy.fit.cantor_pairing:paramagpy.fit.cantor_pairing}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{cantor\_pairing}}}}}(a, b)
&
Map two integers to a single integer.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.fit.clean_indices:paramagpy.fit.clean_indices}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{clean\_indices}}}}}(indices)
&
Uniquely map a list of integers to their smallest size.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.fit.ensemble_average:paramagpy.fit.ensemble_average}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ensemble\_average}}}}}(atoms, *values)
&

\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.fit.extract_ccr:paramagpy.fit.extract_ccr}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{extract\_ccr}}}}}(data)
&
Extract values required for CCR calculations
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.fit.extract_csa:paramagpy.fit.extract_csa}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{extract\_csa}}}}}(data)
&
Extract CSA tensors from atoms
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.fit.extract_pcs:paramagpy.fit.extract_pcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{extract\_pcs}}}}}(data)
&
Extract values required for PCS calculations
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.fit.extract_pre:paramagpy.fit.extract_pre}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{extract\_pre}}}}}(data)
&
Extract values required for PRE calculations
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.fit.extract_rdc:paramagpy.fit.extract_rdc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{extract\_rdc}}}}}(data)
&
Extract values required for RDC calculations
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.fit.nlr_fit_metal_from_ccr:paramagpy.fit.nlr_fit_metal_from_ccr}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{nlr\_fit\_metal\_from\_ccr}}}}}(initMetals, ccrs{[}, …{]})
&
Fit deltaChi tensor to CCR values using non-linear regression.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.fit.nlr_fit_metal_from_pcs:paramagpy.fit.nlr_fit_metal_from_pcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{nlr\_fit\_metal\_from\_pcs}}}}}(initMetals, pcss{[}, …{]})
&
Fit deltaChi tensor to PCS values using non-linear regression.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.fit.nlr_fit_metal_from_pre:paramagpy.fit.nlr_fit_metal_from_pre}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{nlr\_fit\_metal\_from\_pre}}}}}(initMetals, pres{[}, …{]})
&
Fit deltaChi tensor to PRE values using non-linear regression.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.fit.nlr_fit_metal_from_rdc:paramagpy.fit.nlr_fit_metal_from_rdc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{nlr\_fit\_metal\_from\_rdc}}}}}(metal, rdc{[}, params, …{]})
&
Fit deltaChi tensor to RDC values using non-linear regression.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.fit.pcs_fit_error_bootstrap:paramagpy.fit.pcs_fit_error_bootstrap}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pcs\_fit\_error\_bootstrap}}}}}(initMetals, pcss, …)
&
Analyse uncertainty of PCS fit by Bootstrap methods.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.fit.pcs_fit_error_monte_carlo:paramagpy.fit.pcs_fit_error_monte_carlo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pcs\_fit\_error\_monte\_carlo}}}}}(initMetals, pcss, …)
&
Analyse uncertainty of PCS fit by Monte-Carlo simulation This repeatedly adds noise to experimental PCS data and fits the tensor.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.fit.qfactor:paramagpy.fit.qfactor}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{qfactor}}}}}(experiment, calculated{[}, sumIndices{]})
&
Calculate the Q-factor to judge tensor fit quality
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.fit.sphere_grid:paramagpy.fit.sphere_grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{sphere\_grid}}}}}(origin, radius, points)
&
Make a grid of cartesian points within a sphere
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.fit.svd_calc_metal_from_pcs:paramagpy.fit.svd_calc_metal_from_pcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{svd\_calc\_metal\_from\_pcs}}}}}(pos, pcs, idx, errors)
&
Solve PCS equation by single value decomposition.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.fit.svd_calc_metal_from_pcs_offset:paramagpy.fit.svd_calc_metal_from_pcs_offset}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{svd\_calc\_metal\_from\_pcs\_offset}}}}}(pos, pcs, …)
&
Solve PCS equation by single value decomposition with offset.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.fit.svd_calc_metal_from_rdc:paramagpy.fit.svd_calc_metal_from_rdc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{svd\_calc\_metal\_from\_rdc}}}}}(vec, …)
&
Solve RDC equation by single value decomposition.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.fit.svd_fit_metal_from_rdc:paramagpy.fit.svd_fit_metal_from_rdc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{svd\_fit\_metal\_from\_rdc}}}}}(metal, rdc{[}, sumIndices{]})
&
Fit deltaChi tensor to RDC values using SVD algorithm.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.fit.svd_gridsearch_fit_metal_from_pcs:paramagpy.fit.svd_gridsearch_fit_metal_from_pcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{svd\_gridsearch\_fit\_metal\_from\_pcs}}}}}(metals, pcss)
&
Fit deltaChi tensor to PCS values using Single Value Decomposition over a grid of points in a sphere.
\\
\hline
{\hyperref[\detokenize{reference/generated/paramagpy.fit.unique_pairing:paramagpy.fit.unique_pairing}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{unique\_pairing}}}}}(a, b)
&
Bijectively map two integers to a single integer.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\paragraph{paramagpy.fit.cantor\_pairing}
\label{\detokenize{reference/generated/paramagpy.fit.cantor_pairing:paramagpy-fit-cantor-pairing}}\label{\detokenize{reference/generated/paramagpy.fit.cantor_pairing::doc}}\index{cantor\_pairing() (in module paramagpy.fit)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.cantor_pairing:paramagpy.fit.cantor_pairing}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{cantor\_pairing}}}{\emph{a}, \emph{b}}{}
Map two integers to a single integer.
The mapped space is minimum size.
Ordering matters in this case.
see \sphinxhref{https://stackoverflow.com/questions/919612/mapping-two-integers-to-one-in-a-unique-and-deterministic-way/}{Bijective mapping f:ZxZ-\textgreater{}N}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{a}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{b}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} 

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{c} \textendash{} bijective mapping (a, b) -\textgreater{} c

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.clean\_indices}
\label{\detokenize{reference/generated/paramagpy.fit.clean_indices:paramagpy-fit-clean-indices}}\label{\detokenize{reference/generated/paramagpy.fit.clean_indices::doc}}\index{clean\_indices() (in module paramagpy.fit)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.clean_indices:paramagpy.fit.clean_indices}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{clean\_indices}}}{\emph{indices}}{}
Uniquely map a list of integers to their smallest size.
For example: {[}7,4,7,9,9,10,1{]} -\textgreater{} {[}4 2 4 0 0 1 3{]}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{indices}} (\sphinxstyleliteralemphasis{\sphinxupquote{array-like integers}}) \textendash{} a list of integers

\item[{Returns}] \leavevmode
\sphinxstylestrong{new\_indices} \textendash{} the mapped integers with smallest size

\item[{Return type}] \leavevmode
array-like integers

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.ensemble\_average}
\label{\detokenize{reference/generated/paramagpy.fit.ensemble_average:paramagpy-fit-ensemble-average}}\label{\detokenize{reference/generated/paramagpy.fit.ensemble_average::doc}}\index{ensemble\_average() (in module paramagpy.fit)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.ensemble_average:paramagpy.fit.ensemble_average}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{ensemble\_average}}}{\emph{atoms}, \emph{*values}}{}
\end{fulllineitems}



\paragraph{paramagpy.fit.extract\_ccr}
\label{\detokenize{reference/generated/paramagpy.fit.extract_ccr:paramagpy-fit-extract-ccr}}\label{\detokenize{reference/generated/paramagpy.fit.extract_ccr::doc}}\index{extract\_ccr() (in module paramagpy.fit)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.extract_ccr:paramagpy.fit.extract_ccr}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{extract\_ccr}}}{\emph{data}}{}
Extract values required for CCR calculations
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of lists}}) \textendash{} A list with elements {[}Atom1, Atom2, value, error{]}, where Atom is
an Atom object, value is the CCR value, and error is the uncertainty

\item[{Returns}] \leavevmode
\sphinxstylestrong{tuple} \textendash{} all information required for CCR calculations

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.extract\_csa}
\label{\detokenize{reference/generated/paramagpy.fit.extract_csa:paramagpy-fit-extract-csa}}\label{\detokenize{reference/generated/paramagpy.fit.extract_csa::doc}}\index{extract\_csa() (in module paramagpy.fit)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.extract_csa:paramagpy.fit.extract_csa}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{extract\_csa}}}{\emph{data}}{}
Extract CSA tensors from atoms
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of lists}}) \textendash{} A list with elements {[}Atom, value, error{]}, where Atom is
an Atom object, value is the PCS/RDC/PRE value,
and error is the uncertainty

\item[{Returns}] \leavevmode
\sphinxstylestrong{csas} \textendash{} an array of each CSA tensor

\item[{Return type}] \leavevmode
array of 3x3 arrays

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.extract\_pcs}
\label{\detokenize{reference/generated/paramagpy.fit.extract_pcs:paramagpy-fit-extract-pcs}}\label{\detokenize{reference/generated/paramagpy.fit.extract_pcs::doc}}\index{extract\_pcs() (in module paramagpy.fit)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.extract_pcs:paramagpy.fit.extract_pcs}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{extract\_pcs}}}{\emph{data}}{}
Extract values required for PCS calculations
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of lists}}) \textendash{} A list with elements {[}Atom, value, error{]}, where Atom is
an Atom object, value is the PCS value, and error is the uncertainty

\item[{Returns}] \leavevmode
\sphinxstylestrong{tuple} \textendash{} all information required for PCS calculations

\item[{Return type}] \leavevmode
(atom coordinates, PCS values, PCS errors, atom indices)

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.extract\_pre}
\label{\detokenize{reference/generated/paramagpy.fit.extract_pre:paramagpy-fit-extract-pre}}\label{\detokenize{reference/generated/paramagpy.fit.extract_pre::doc}}\index{extract\_pre() (in module paramagpy.fit)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.extract_pre:paramagpy.fit.extract_pre}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{extract\_pre}}}{\emph{data}}{}
Extract values required for PRE calculations
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of lists}}) \textendash{} A list with elements {[}Atom, value, error{]}, where Atom is
an Atom object, value is the PRE value, and error is the uncertainty

\item[{Returns}] \leavevmode
\sphinxstylestrong{tuple} \textendash{} all information required for PRE calculations

\item[{Return type}] \leavevmode
(atom coordinates, PRE values, PRE errors, atom indices)

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.extract\_rdc}
\label{\detokenize{reference/generated/paramagpy.fit.extract_rdc:paramagpy-fit-extract-rdc}}\label{\detokenize{reference/generated/paramagpy.fit.extract_rdc::doc}}\index{extract\_rdc() (in module paramagpy.fit)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.extract_rdc:paramagpy.fit.extract_rdc}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{extract\_rdc}}}{\emph{data}}{}
Extract values required for RDC calculations
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of lists}}) \textendash{} A list with elements {[}Atom1, Atom2, value, error{]}, where Atom is
an Atom object, value is the RDC value, and error is the uncertainty

\item[{Returns}] \leavevmode
\sphinxstylestrong{tuple} \textendash{}         RDC errors, atom indices)
all information required for RDC calculations and fitting

\item[{Return type}] \leavevmode
(inter-atomic vector, gamma values, RDC values,

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.nlr\_fit\_metal\_from\_ccr}
\label{\detokenize{reference/generated/paramagpy.fit.nlr_fit_metal_from_ccr:paramagpy-fit-nlr-fit-metal-from-ccr}}\label{\detokenize{reference/generated/paramagpy.fit.nlr_fit_metal_from_ccr::doc}}\index{nlr\_fit\_metal\_from\_ccr() (in module paramagpy.fit)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.nlr_fit_metal_from_ccr:paramagpy.fit.nlr_fit_metal_from_ccr}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{nlr\_fit\_metal\_from\_ccr}}}{\emph{initMetals}, \emph{ccrs}, \emph{params=('x'}, \emph{'y'}, \emph{'z')}, \emph{sumIndices=None}, \emph{progress=None}}{}
Fit deltaChi tensor to CCR values using non-linear regression.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{initMetals}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of Metal objects}}) \textendash{} a list of metals used as starting points for fitting.
a list must always be provided, but may also contain
only one element. If multiple metals are provided, each metal
is fitted to their respective CCR dataset by index, but all are
fitted to a common position.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ccrs}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of CCR datasets}}) \textendash{} each CCR dataset must correspond to an associated metal for fitting.
each CCR dataset has structure {[}Atom, value, error{]}, where Atom is
an Atom object, value is the PCS/RDC/PRE/CCR value
and error is the uncertainty

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{params}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of str}}) \textendash{} the parameters to be fit.
For example {[}‘x’,’y’,’z’,’ax’,’rh’,’a’,’b’,’g’,’shift’{]}
This defaults to {[}‘x’,’y’,’z’{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sumIndices}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of arrays of ints}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} each index list must correspond to an associated ccr dataset.
each index list contains an index assigned to each atom.
Common indices determine summation between models
for ensemble averaging.
If None, defaults to atom serial number to determine summation
between models.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{progress}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} to keep track of the calculation, progress.set(x) is called each
iteration and varies from 0.0 -\textgreater{} 1.0 when the calculation is complete.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{metals} (\sphinxstyleemphasis{list of metals}) \textendash{} the metals fitted by NLR to the CCR data provided

\item {} 
\sphinxstylestrong{calc\_ccrs} (\sphinxstyleemphasis{list of lists of floats}) \textendash{} the calculated CCR values

\item {} 
\sphinxstylestrong{qfactors} (\sphinxstyleemphasis{list})

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.nlr\_fit\_metal\_from\_pcs}
\label{\detokenize{reference/generated/paramagpy.fit.nlr_fit_metal_from_pcs:paramagpy-fit-nlr-fit-metal-from-pcs}}\label{\detokenize{reference/generated/paramagpy.fit.nlr_fit_metal_from_pcs::doc}}\index{nlr\_fit\_metal\_from\_pcs() (in module paramagpy.fit)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.nlr_fit_metal_from_pcs:paramagpy.fit.nlr_fit_metal_from_pcs}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{nlr\_fit\_metal\_from\_pcs}}}{\emph{initMetals}, \emph{pcss}, \emph{params=('x'}, \emph{'y'}, \emph{'z'}, \emph{'ax'}, \emph{'rh'}, \emph{'a'}, \emph{'b'}, \emph{'g')}, \emph{sumIndices=None}, \emph{userads=False}, \emph{useracs=False}, \emph{progress=None}}{}
Fit deltaChi tensor to PCS values using non-linear regression.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{initMetals}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of Metal objects}}) \textendash{} a list of metals used as starting points for fitting.
a list must always be provided, but may also contain
only one element. If multiple metals are provided, each metal
is fitted to their respective PCS dataset by index, but all are
fitted to a common position.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pcss}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of PCS datasets}}) \textendash{} each PCS dataset must correspond to an associated metal for fitting.
each PCS dataset has structure {[}Atom, value, error{]}, where Atom is
an Atom object, value is the PCS/RDC/PRE value
and error is the uncertainty

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{params}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of str}}) \textendash{} the parameters to be fit.
For example {[}‘x’,’y’,’z’,’ax’,’rh’,’a’,’b’,’g’,’shift’{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sumIndices}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of arrays of ints}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} each index list must correspond to an associated pcs dataset.
each index list contains an index assigned to each atom.
Common indices determine summation between models
for ensemble averaging.
If None, defaults to atom serial number to determine summation
between models.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{userads}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} include residual anisotropic dipolar shielding (RADS) during fitting

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{useracs}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} include residual anisotropic chemical shielding (RACS) during fitting.
CSA tensors are taken using the \textless{}csa\textgreater{} method of atoms.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{progress}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} to keep track of the calculation, progress.set(x) is called each
iteration and varies from 0.0 -\textgreater{} 1.0 when the calculation is complete.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{metals} (\sphinxstyleemphasis{list of metals}) \textendash{} the metals fitted by NLR to the PCS data provided

\item {} 
\sphinxstylestrong{calc\_pcss} (\sphinxstyleemphasis{list of lists of floats}) \textendash{} the calculated PCS values

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.nlr\_fit\_metal\_from\_pre}
\label{\detokenize{reference/generated/paramagpy.fit.nlr_fit_metal_from_pre:paramagpy-fit-nlr-fit-metal-from-pre}}\label{\detokenize{reference/generated/paramagpy.fit.nlr_fit_metal_from_pre::doc}}\index{nlr\_fit\_metal\_from\_pre() (in module paramagpy.fit)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.nlr_fit_metal_from_pre:paramagpy.fit.nlr_fit_metal_from_pre}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{nlr\_fit\_metal\_from\_pre}}}{\emph{initMetals}, \emph{pres}, \emph{params=('x'}, \emph{'y'}, \emph{'z')}, \emph{sumIndices=None}, \emph{rtypes=None}, \emph{usesbm=True}, \emph{usedsa=True}, \emph{usecsa=False}, \emph{progress=None}}{}
Fit deltaChi tensor to PRE values using non-linear regression.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{initMetals}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of Metal objects}}) \textendash{} a list of metals used as starting points for fitting.
a list must always be provided, but may also contain
only one element. If multiple metals are provided, each metal
is fitted to their respective PRE dataset by index, but all are
fitted to a common position.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pres}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of PRE datasets}}) \textendash{} each PRE dataset must correspond to an associated metal for fitting.
each PRE dataset has structure {[}Atom, value, error{]}, where Atom is
an Atom object, value is the PCS/RDC/PRE value
and error is the uncertainty

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{params}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of str}}) \textendash{} the parameters to be fit.
For example {[}‘x’,’y’,’z’,’ax’,’rh’,’a’,’b’,’g’,’iso’,’taur’,’t1e’{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sumIndices}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of arrays of ints}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} each index list must correspond to an associated pcs dataset.
each index list contains an index assigned to each atom.
Common indices determine summation between models
for ensemble averaging.
If None, defaults to atom serial number to determine summation
between models.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rtypes}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} the relaxtion type, either ‘r1’ or ‘r2’. A list must be provided with
each element corresponding to an associated dataset.
Defaults to ‘r2’ for all datasets of None is specified.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{usesbm}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} include Solomon-Bloemenbergen-Morgan (Dipole-dipole) relaxation theory.
default is True

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{usedsa}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} include Dipolar-Shielding-Anisotropy (Curie Spin) relaxation theory.
default is True

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{usecsa}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} include Chemical-Shift-Anisotropy cross-correlated realxation theory.
default is False

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{progress}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} to keep track of the calculation, progress.set(x) is called each
iteration and varies from 0.0 -\textgreater{} 1.0 when the calculation is complete.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{metals} \textendash{} the metals fitted by NLR to the PRE data provided

\item[{Return type}] \leavevmode
list of metals

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.nlr\_fit\_metal\_from\_rdc}
\label{\detokenize{reference/generated/paramagpy.fit.nlr_fit_metal_from_rdc:paramagpy-fit-nlr-fit-metal-from-rdc}}\label{\detokenize{reference/generated/paramagpy.fit.nlr_fit_metal_from_rdc::doc}}\index{nlr\_fit\_metal\_from\_rdc() (in module paramagpy.fit)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.nlr_fit_metal_from_rdc:paramagpy.fit.nlr_fit_metal_from_rdc}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{nlr\_fit\_metal\_from\_rdc}}}{\emph{metal}, \emph{rdc}, \emph{params=('ax'}, \emph{'rh'}, \emph{'a'}, \emph{'b'}, \emph{'g')}, \emph{sumIndices=None}, \emph{progress=None}}{}
Fit deltaChi tensor to RDC values using non-linear regression.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{metal}} (\sphinxstyleliteralemphasis{\sphinxupquote{Metal object}}) \textendash{} the starting metal for fitting

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rdc}} (\sphinxstyleliteralemphasis{\sphinxupquote{the RDC dataset}}) \textendash{} each RDC dataset has structure {[}Atom, value, error{]}, where Atom is
an Atom object, value is the PCS/RDC/PRE value
and error is the uncertainty

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{params}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} the parameters to be fit.
this defaults to {[}‘ax’,’rh’,’a’,’b’,’g’{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sumIndices}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of ints}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} the list contains an index assigned to each atom.
Common indices determine summation between models
for ensemble averaging.
If None, defaults to atom serial number to determine summation
between models.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{progress}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} to keep track of the calculation, progress.set(x) is called each
iteration and varies from 0.0 -\textgreater{} 1.0 when the calculation is complete.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{fitMetal} (\sphinxstyleemphasis{Metal object}) \textendash{} the fitted metal by NLR to the RDC data provided

\item {} 
\sphinxstylestrong{calculated} (\sphinxstyleemphasis{array of floats}) \textendash{} the calculated RDC values

\item {} 
\sphinxstylestrong{qfac} (\sphinxstyleemphasis{float}) \textendash{} the qfactor judging the fit quality

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.pcs\_fit\_error\_bootstrap}
\label{\detokenize{reference/generated/paramagpy.fit.pcs_fit_error_bootstrap:paramagpy-fit-pcs-fit-error-bootstrap}}\label{\detokenize{reference/generated/paramagpy.fit.pcs_fit_error_bootstrap::doc}}\index{pcs\_fit\_error\_bootstrap() (in module paramagpy.fit)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.pcs_fit_error_bootstrap:paramagpy.fit.pcs_fit_error_bootstrap}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{pcs\_fit\_error\_bootstrap}}}{\emph{initMetals}, \emph{pcss}, \emph{iterations}, \emph{fraction}, \emph{params=('x'}, \emph{'y'}, \emph{'z'}, \emph{'ax'}, \emph{'rh'}, \emph{'a'}, \emph{'b'}, \emph{'g')}, \emph{sumIndices=None}, \emph{userads=False}, \emph{useracs=False}, \emph{progress=None}}{}
Analyse uncertainty of PCS fit by Bootstrap methods.
This repeats the tensor fitting, but each time samples a fraction
of the data randomly. The standard deviation in fitted parameters
over each iteration is then reported.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{initMetals}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of Metal objects}}) \textendash{} a list of metals used as starting points for fitting.
a list must always be provided, but may also contain
only one element. If multiple metals are provided, each metal
is fitted to their respective PCS dataset by index, but all are
fitted to a common position.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pcss}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of PCS datasets}}) \textendash{} each PCS dataset must correspond to an associated metal for fitting.
each PCS dataset has structure {[}Atom, value, error{]}, where Atom is
an Atom object, value is the PCS/RDC/PRE value
and error is the uncertainty

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{iterations}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} the number of Monte Carlo iterations to perform

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fraction}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} must be between 0 and 1
the proportion of data to be sample for fitting with each iteration
of the bootstrap method.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{params}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of str}}) \textendash{} the parameters to be fit.
For example {[}‘x’,’y’,’z’,’ax’,’rh’,’a’,’b’,’g’,’shift’{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sumIndices}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of arrays of ints}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} each index list must correspond to an associated pcs dataset.
each index list contains an index assigned to each atom.
Common indices determine summation between models
for ensemble averaging.
If None, defaults to atom serial number to determine summation
between models.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{userads}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} include residual anisotropic dipolar shielding (RADS) during fitting

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{useracs}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} include residual anisotropic chemical shielding (RACS) during fitting.
CSA tensors are taken using the \textless{}csa\textgreater{} method of atoms.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{progress}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} to keep track of the calculation, progress.set(x) is called each
iteration and varies from 0.0 -\textgreater{} 1.0 when the calculation is complete.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{sample\_metals} (\sphinxstyleemphasis{list of list of metals}) \textendash{} the metals fitted by NLR to the PCS data with noise at each iteration

\item {} 
\sphinxstylestrong{std\_metals} (\sphinxstyleemphasis{list of metals}) \textendash{} the standard deviation in fitted parameters over all iterations of the
Monte Carlo simulation.
These are stored within the metal object. All unfitted parameters
are zero.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.pcs\_fit\_error\_monte\_carlo}
\label{\detokenize{reference/generated/paramagpy.fit.pcs_fit_error_monte_carlo:paramagpy-fit-pcs-fit-error-monte-carlo}}\label{\detokenize{reference/generated/paramagpy.fit.pcs_fit_error_monte_carlo::doc}}\index{pcs\_fit\_error\_monte\_carlo() (in module paramagpy.fit)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.pcs_fit_error_monte_carlo:paramagpy.fit.pcs_fit_error_monte_carlo}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{pcs\_fit\_error\_monte\_carlo}}}{\emph{initMetals}, \emph{pcss}, \emph{iterations}, \emph{params=('x'}, \emph{'y'}, \emph{'z'}, \emph{'ax'}, \emph{'rh'}, \emph{'a'}, \emph{'b'}, \emph{'g')}, \emph{sumIndices=None}, \emph{userads=False}, \emph{useracs=False}, \emph{progress=None}}{}
Analyse uncertainty of PCS fit by Monte-Carlo simulation
This repeatedly adds noise to experimental PCS data and fits the tensor.
The standard deviation of the fitted parameters across each iteration
is then reported.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{initMetals}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of Metal objects}}) \textendash{} a list of metals used as starting points for fitting.
a list must always be provided, but may also contain
only one element. If multiple metals are provided, each metal
is fitted to their respective PCS dataset by index, but all are
fitted to a common position.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pcss}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of PCS datasets}}) \textendash{} each PCS dataset must correspond to an associated metal for fitting.
each PCS dataset has structure {[}Atom, value, error{]}, where Atom is
an Atom object, value is the PCS/RDC/PRE value
and error is the uncertainty

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{iterations}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} the number of Monte Carlo iterations to perform

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{params}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of str}}) \textendash{} the parameters to be fit.
For example {[}‘x’,’y’,’z’,’ax’,’rh’,’a’,’b’,’g’,’shift’{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sumIndices}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of arrays of ints}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} each index list must correspond to an associated pcs dataset.
each index list contains an index assigned to each atom.
Common indices determine summation between models
for ensemble averaging.
If None, defaults to atom serial number to determine summation
between models.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{userads}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} include residual anisotropic dipolar shielding (RADS) during fitting

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{useracs}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} include residual anisotropic chemical shielding (RACS) during fitting.
CSA tensors are taken using the \textless{}csa\textgreater{} method of atoms.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{progress}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} to keep track of the calculation, progress.set(x) is called each
iteration and varies from 0.0 -\textgreater{} 1.0 when the calculation is complete.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{sample\_metals} (\sphinxstyleemphasis{list of list of metals}) \textendash{} the metals fitted by NLR to the PCS data with noise at each iteration

\item {} 
\sphinxstylestrong{std\_metals} (\sphinxstyleemphasis{list of metals}) \textendash{} the standard deviation in fitted parameters over all iterations of the
Monte Carlo simulation.
These are stored within the metal object. All unfitted parameters
are zero.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.qfactor}
\label{\detokenize{reference/generated/paramagpy.fit.qfactor:paramagpy-fit-qfactor}}\label{\detokenize{reference/generated/paramagpy.fit.qfactor::doc}}\index{qfactor() (in module paramagpy.fit)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.qfactor:paramagpy.fit.qfactor}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{qfactor}}}{\emph{experiment}, \emph{calculated}, \emph{sumIndices=None}}{}
Calculate the Q-factor to judge tensor fit quality

A lower value indicates a better fit. The Q-factor is calculated using
the following equation:
\begin{equation*}
\begin{split}Q = \sqrt{
        \frac{\sum_i\left[\left(\sum_m\left[
        PCS^{exp}_{m,i}-PCS^{calc}_{m,i}\right]\right)^2\right]}
        {\sum_i\left[
        \left(\sum_m\left[PCS^{exp}_{m,i}\right]\right)^2\right]}
}\end{split}
\end{equation*}
where \(m\) and \(i\) are usually indexed over models and atoms
respectively.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{experiment}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of floats}}) \textendash{} the experimental values

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{calculated}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of floats}}) \textendash{} the corresponding caluclated values from the fitted model

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sumIndices}} (\sphinxstyleliteralemphasis{\sphinxupquote{list ints}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Common indices determine summation between models
for ensemble averaging.
If None, no ensemble averaging is conducted

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{qfactor} \textendash{} the Q-factor

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.sphere\_grid}
\label{\detokenize{reference/generated/paramagpy.fit.sphere_grid:paramagpy-fit-sphere-grid}}\label{\detokenize{reference/generated/paramagpy.fit.sphere_grid::doc}}\index{sphere\_grid() (in module paramagpy.fit)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.sphere_grid:paramagpy.fit.sphere_grid}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{sphere\_grid}}}{\emph{origin}, \emph{radius}, \emph{points}}{}
Make a grid of cartesian points within a sphere
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{origin}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} the centre of the sphere

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{radius}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} the radius of the sphere

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{points}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} the number of points per radius

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{array} \textendash{} the points within the sphere

\item[{Return type}] \leavevmode
array of {[}x,y,z{]} coordinates

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.svd\_calc\_metal\_from\_pcs}
\label{\detokenize{reference/generated/paramagpy.fit.svd_calc_metal_from_pcs:paramagpy-fit-svd-calc-metal-from-pcs}}\label{\detokenize{reference/generated/paramagpy.fit.svd_calc_metal_from_pcs::doc}}\index{svd\_calc\_metal\_from\_pcs() (in module paramagpy.fit)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.svd_calc_metal_from_pcs:paramagpy.fit.svd_calc_metal_from_pcs}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{svd\_calc\_metal\_from\_pcs}}}{\emph{pos}, \emph{pcs}, \emph{idx}, \emph{errors}}{}
Solve PCS equation by single value decomposition.
This function is generally called by higher methods like
\textless{}svd\_gridsearch\_fit\_metal\_from\_pcs\textgreater{}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pos}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{x}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{y}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{z}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{floats}}) \textendash{} the atomic positions in meters

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pcs}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}) \textendash{} the PCS values in ppm

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of ints}}) \textendash{} an index assigned to each atom. Common indices determine summation
between models for ensemble averaging.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{errors}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}) \textendash{} the standard deviation representing experimental uncertainty
in the measured value

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{tuple} \textendash{} calc are the calculated PCS values from the fitted tensor
sol is the solution to the linearised PCS equation and
consists of the tensor matrix elements

\item[{Return type}] \leavevmode
(calc, sol)

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.svd\_calc\_metal\_from\_pcs\_offset}
\label{\detokenize{reference/generated/paramagpy.fit.svd_calc_metal_from_pcs_offset:paramagpy-fit-svd-calc-metal-from-pcs-offset}}\label{\detokenize{reference/generated/paramagpy.fit.svd_calc_metal_from_pcs_offset::doc}}\index{svd\_calc\_metal\_from\_pcs\_offset() (in module paramagpy.fit)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.svd_calc_metal_from_pcs_offset:paramagpy.fit.svd_calc_metal_from_pcs_offset}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{svd\_calc\_metal\_from\_pcs\_offset}}}{\emph{pos}, \emph{pcs}, \emph{idx}, \emph{errors}}{}
Solve PCS equation by single value decomposition with offset.
An offset arising from referencing errors between diamagnetic
and paramagnetic datasets can be accounted for using this method.
This function is generally called by higher methods like
\textless{}svd\_gridsearch\_fit\_metal\_from\_pcs\textgreater{}

NOTE: the factor of 1E26 is required for floating point error mitigation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pos}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{x}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{y}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{z}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{floats}}) \textendash{} the atomic positions in meters

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pcs}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}) \textendash{} the PCS values in ppm

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of ints}}) \textendash{} an index assigned to each atom. Common indices determine summation
between models for ensemble averaging.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{errors}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}) \textendash{} the standard deviation representing experimental uncertainty
in the measured value

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{tuple} \textendash{} calc are the calculated PCS values from the fitted tensor
sol is the solution to the linearised PCS equation and
consists of the tensor matrix elements and offset

\item[{Return type}] \leavevmode
(calc, sol)

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.svd\_calc\_metal\_from\_rdc}
\label{\detokenize{reference/generated/paramagpy.fit.svd_calc_metal_from_rdc:paramagpy-fit-svd-calc-metal-from-rdc}}\label{\detokenize{reference/generated/paramagpy.fit.svd_calc_metal_from_rdc::doc}}\index{svd\_calc\_metal\_from\_rdc() (in module paramagpy.fit)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.svd_calc_metal_from_rdc:paramagpy.fit.svd_calc_metal_from_rdc}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{svd\_calc\_metal\_from\_rdc}}}{\emph{vec}, \emph{rdc\_parameterised}, \emph{idx}, \emph{errors}}{}
Solve RDC equation by single value decomposition.
This function is generally called by higher methods like
\textless{}svd\_fit\_metal\_from\_rdc\textgreater{}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{vec}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{x}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{y}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{z}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{floats}}) \textendash{} the internuclear vectors in meters

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rdc\_parameterised}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}) \textendash{} the experimental RDC values, normalised by a prefactor

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of ints}}) \textendash{} an index assigned to each atom. Common indices determine summation
between models for ensemble averaging.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{errors}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}) \textendash{} the standard deviation representing experimental uncertainty
in the measured value

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{calc} (\sphinxstyleemphasis{array of floats}) \textendash{} the calculated RDC values from the fitted tensor

\item {} 
\sphinxstylestrong{sol} (\sphinxstyleemphasis{array of floats}) \textendash{} sol is the solution to the linearised PCS equation and
consists of the tensor matrix elements

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.svd\_fit\_metal\_from\_rdc}
\label{\detokenize{reference/generated/paramagpy.fit.svd_fit_metal_from_rdc:paramagpy-fit-svd-fit-metal-from-rdc}}\label{\detokenize{reference/generated/paramagpy.fit.svd_fit_metal_from_rdc::doc}}\index{svd\_fit\_metal\_from\_rdc() (in module paramagpy.fit)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.svd_fit_metal_from_rdc:paramagpy.fit.svd_fit_metal_from_rdc}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{svd\_fit\_metal\_from\_rdc}}}{\emph{metal}, \emph{rdc}, \emph{sumIndices=None}}{}
Fit deltaChi tensor to RDC values using SVD algorithm.
Note this is a weighted SVD calculation which takes into account
experimental errors.
Ensemble averaging defaults to atom numbers.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{metal}} (\sphinxstyleliteralemphasis{\sphinxupquote{Metal object}}) \textendash{} the starting metal for fitting

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rdc}} (\sphinxstyleliteralemphasis{\sphinxupquote{the RDC dataset}}) \textendash{} each RDC dataset has structure {[}(Atom1, Atom2), value, error{]},
where Atom is an Atom object, value is the RDC value
and error is the uncertainty

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sumIndices}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of ints}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} the list contains an index assigned to each atom.
Common indices determine summation between models
for ensemble averaging.
If None, defaults to atom serial number to determine summation
between models.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{fitMetal} (\sphinxstyleemphasis{Metal object}) \textendash{} the fitted metal by NLR to the RDC data provided

\item {} 
\sphinxstylestrong{calculated} (\sphinxstyleemphasis{array of floats}) \textendash{} the calculated RDC values

\item {} 
\sphinxstylestrong{qfac} (\sphinxstyleemphasis{float}) \textendash{} the qfactor judging the fit quality

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.svd\_gridsearch\_fit\_metal\_from\_pcs}
\label{\detokenize{reference/generated/paramagpy.fit.svd_gridsearch_fit_metal_from_pcs:paramagpy-fit-svd-gridsearch-fit-metal-from-pcs}}\label{\detokenize{reference/generated/paramagpy.fit.svd_gridsearch_fit_metal_from_pcs::doc}}\index{svd\_gridsearch\_fit\_metal\_from\_pcs() (in module paramagpy.fit)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.svd_gridsearch_fit_metal_from_pcs:paramagpy.fit.svd_gridsearch_fit_metal_from_pcs}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{svd\_gridsearch\_fit\_metal\_from\_pcs}}}{\emph{metals}, \emph{pcss}, \emph{sumIndices=None}, \emph{origin=None}, \emph{radius=20.0}, \emph{points=16}, \emph{offsetShift=False}, \emph{progress=None}}{}
Fit deltaChi tensor to PCS values using Single Value Decomposition over
a grid of points in a sphere.
Note this uses a weighted SVD fit which takes into account
experimental errors
Ensemble averaging is determined by atom number.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{metals}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of Metal objects}}) \textendash{} a list of metals used as starting points for fitting.
a list must always be provided, but may also contain
only one element. If multiple metals are provided, each metal
is fitted to their respective PCS dataset by index, but all are
fitted to a common position.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pcss}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of PCS datasets}}) \textendash{} each PCS dataset must correspond to an associated metal for fitting.
each PCS dataset has structure {[}Atom, value, error{]}, where Atom is
an Atom object, value is the PCS/RDC/PRE value
and error is the uncertainty

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sumIndices}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of arrays of ints}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} each index list must correspond to an associated pcs dataset.
each index list contains an index assigned to each atom.
Common indices determine summation between models
for ensemble averaging.
If None, defaults to atom serial number to determine summation
between models.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{origin}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} the centre of the gridsearch of positions in Angstroms.
If None, the position of the first metal is used

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{radius}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} the radius of the gridsearch in Angstroms.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{points}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} the number of points per radius in the gridsearch

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{offsetShift}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} if True, an offset value added to all PCS values is included in
the SVD fitting. This may arise due to a referencing error between
diamagnetic and paramagnetic PCS datasets and may be used when
many data points are available.
Default False, no offset is included in the fitting.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{progress}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} to keep track of the calculation, progress.set(x) is called each
iteration and varies from 0.0 -\textgreater{} 1.0 when the calculation is complete.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{minmetals} \textendash{} the metals fitted by SVD to the PCS data provided

\item[{Return type}] \leavevmode
list of metals

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.unique\_pairing}
\label{\detokenize{reference/generated/paramagpy.fit.unique_pairing:paramagpy-fit-unique-pairing}}\label{\detokenize{reference/generated/paramagpy.fit.unique_pairing::doc}}\index{unique\_pairing() (in module paramagpy.fit)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.unique_pairing:paramagpy.fit.unique_pairing}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{unique\_pairing}}}{\emph{a}, \emph{b}}{}
Bijectively map two integers to a single integer.
The mapped space is minimum size.
The input is symmetric.
see \sphinxhref{https://stackoverflow.com/questions/919612/mapping-two-integers-to-one-in-a-unique-and-deterministic-way/}{Bijective mapping f:ZxZ-\textgreater{}N}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{a}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{b}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} 

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{c} \textendash{} bijective symmetric mapping (a, b) \textbar{} (b, a) -\textgreater{} c

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}



\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{p}
\item\relax\sphinxstyleindexentry{paramagpy.dataparse}\sphinxstyleindexpageref{reference/dataparse:\detokenize{module-paramagpy.dataparse}}
\item\relax\sphinxstyleindexentry{paramagpy.fit}\sphinxstyleindexpageref{reference/generated/paramagpy.fit:\detokenize{module-paramagpy.fit}}
\item\relax\sphinxstyleindexentry{paramagpy.metal}\sphinxstyleindexpageref{reference/metal:\detokenize{module-paramagpy.metal}}
\item\relax\sphinxstyleindexentry{paramagpy.protein}\sphinxstyleindexpageref{reference/protein:\detokenize{module-paramagpy.protein}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}